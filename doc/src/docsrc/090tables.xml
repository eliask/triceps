<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5CR3//EN"
	"http://www.oasis-open.org/docbook/xml/4.5CR3/docbookx.dtd" [
<!ENTITY % userents SYSTEM "file:///ENTS/user.ent" >
%userents;
]>

<!--
(C) Copyright 2011-2012 Sergey A. Babkin.
This file is a part of Triceps.
See the file COPYRIGHT for the copyright notice and license information
-->

<chapter id="ch_tables" xmlns:xi="http://www.w3.org/2001/XInclude">
	<title>Tables</title>

	<sect1 id="sc_table_hello">
		<title>Hello, tables!</title>

		<indexterm>
			<primary>table</primary>
		</indexterm>

		<para>
		The tables are the fundamental elements of state-keeping in Triceps. 
		Let's start with a basic example:
		</para>

		<indexterm>
			<primary>table</primary>
			<secondary>insert</secondary>
		</indexterm>

<!-- t/xHelloTable.t helloWorldDirect reduced, shifted left -->
<pre>
my $hwunit = Triceps::Unit->new("hwunit") or confess "$!";
my $rtCount = Triceps::RowType->new(
	address => "string",
	count => "int32",
) or confess "$!";

my $ttCount = Triceps::TableType->new($rtCount)
	->addSubIndex("byAddress", 
		Triceps::IndexType->newHashed(key => [ "address" ])
	)
or confess "$!";
$ttCount->initialize() or confess "$!";

my $tCount = $hwunit->makeTable($ttCount, &Triceps::EM_CALL, "tCount") 
	or confess "$!";

while(&readLine) {
	chomp;
	my @data = split(/\W+/);

	# the common part: find if there already is a count for this address
	my $rhFound = $tCount->findBy(
		address => $data[1]
	);
	my $cnt = 0;
	if (!$rhFound->isNull()) {
		$cnt = $rhFound->getRow()->get("count");
	}

	if ($data[0] =~ /^hello$/i) {
		my $new = $rtCount->makeRowHash(
			address => $data[1],
			count => $cnt+1,
		) or confess "$!";
		$tCount->insert($new);
	} elsif ($data[0] =~ /^count$/i) {
		&send("Received '", $data[1], "' ", $cnt + 0, " times\n");
	} else {
		&send("Unknown command '$data[0]'\n");
	}
}
</pre>

		<para>
		What happens here? The main loop reads the lines from standard input, splits
		into words and uses
		the first word as a command and the second word as a key. Note that
		it's not CSV format, it's words with the non-alphanumeric characters separating
		the words. <quote>Hello, table!</quote>, <quote>hello world</quote>, <quote>count world</quote> are examples
		of the valid inputs. For someting different, the commands are compared
		with their case ignored (but the case matters for the key).
		</para>

		<para>
		The example counts,
		how many times each key has been <pre>hello</pre>-ed, and prints this count back
		on the command <pre>count</pre>. Here is a sample, with the input
		lines printed in italics:
		</para>

<exdump>
> Hello, table!
> Hello, world!
> Hello, table!
> count world
Received 'world' 1 times
> Count table
Received 'table' 2 times
</exdump>

		<indexterm>
			<primary>table</primary>
			<secondary>procedural API</secondary>
		</indexterm>
		<para>
		In this example the table is read and modified using the direct procedural calls.
		As you can see, there isn't even any need for unit scheduling and
		such. There is a scheduler-based interface to the tables too, it will be shown
		soon. But in many cases the direct access is easier. Indeed,
		this particular example could have been implemented with the plain Perl
		hashes. Nothing wrong with that either. Well, the Perl tables provide
		many more intersting ways of indexing the data. But if you don't need them,
		they don't matter. And at some future point the
		tables will be supporting the on-disk persistence, but no reason to
		bother much about that now: things are likely to change a dozen times
		yet before that happens. Feel free to just use the Perl data structures
		if they make the code easier.
		</para>

		<para>
		A table is created through a table type. This allows to stamp out
		duplicate tables of the same type, which can get handy when the
		multithreading will be added. A table is local to a thread. A table
		type can be shared between threads. To look up
		something in another thread's table, you'd either have to ask it
		through a request-reply protocol or to keep a local copy of the table.
		Such a copy can be easily done by creating a copy table from the same type.
		</para>

		<para>
		In reality, right now all the business with table types separated from
		the tables is more pain than gain. It not only adds extra steps but
		also makes difficult to define a template that acts on a table by
		defining extra features on it. Something will be done about it, I have
		a few ideas.
		</para>

		<para>
		The table type gets first created and configured, then initialized.
		After a table type is initialized, it can not be changed any more.
		That's the point of the initialization call: tell the type that all
		the configuration has been done, and it can go immutable now. 
		Fundamentally, configuting a table type just makes it collect
		bits and pieces. Nothing but the most gross errors can be detected
		at that point. At initialization time everything comes together
		and everything gets checked for consistency.  A table
		type must be fully initialized in one thread before it can be shared
		with other threads. The historic reason for this API is that it mirrors
		the &Cpp; API, which has turned out not to look that good in Perl. It's
		another candidate for a change. 
		</para>

		<indexterm>
			<primary>index</primary>
			<secondary>hashed</secondary>
		</indexterm>
		<para>
		A table type gets the row type and at least one index. Here it's a
		hashed index by the key field <pre>address</pre>. "Hashed" means that
		you can look up the rows by the key value but there are no promises
		about any specific row order. And the hashing is used to make the
		key comparisons more efficient. The key of a hashed index may
		consist of multiple fields.
		</para>

		<para>
		The table is then created from the table type, enqueueing mode 
		(another hold-over, just always use <pre>EM_CALL</pre>, this
		argument will be removed in the future), and given a name.
		</para>

		<para>
		The rows can then be inserted into the table (and removed too, not
		shown in this example yet). The default behavior of the hashed index is to
		replace the old row if a new row with the same key is inserted.
		</para>

		<indexterm>
			<primary>table</primary>
			<secondary>find</secondary>
		</indexterm>
		<indexterm>
			<primary>RowHandle</primary>
		</indexterm>
		<para>
		The search in the table is done by the method <pre>findBy()</pre> with 
		the key fields of the index.  Which returns a RowHandle
		object. A RowHandle is essentially an iterator in the table. Even if
		the row is not found, a RowHandle will be still returned but it will be
		NULL, which is checked for by <pre>$rh->isNull()</pre>.
		</para>

		<para>
		No matter which command will be used, it's always useful to look up
		the previous row for the key: its contents would be either printed
		or provide the previous value for the increase. So the model does
		it first and gets the count from it. If it's not found, then the 
		count is set to 0. 
		</para>

		<para>
		Then it looks at the command and does what it's been told.
		Updating the count amounts to creating a new row with the new
		values and inserting it into the table. It replaces the previous one.
		</para>

		<para>
		This is just the tip of the iceberg. The tables in Triceps have a lot
		more features.
		</para>
	</sect1>

	<sect1 id="sc_table_label">
		<title>Tables and labels</title>

		<indexterm>
			<primary>label</primary>
		</indexterm>

		<para>
		A table does not have to be operated in a procedural way. It can be
		plugged into the the scheduler machinery. Whenever a table is created,
		three labels are created with it.
		</para>

		<indexterm>
			<primary>label</primary>
			<secondary>table</secondary>
		</indexterm>
		<indexterm>
			<primary>table</primary>
			<secondary>label API</secondary>
		</indexterm>
		<itemizedlist>
		<listitem>
		The input label is for sending the modification rowops to the
		table. The table provides the handler for it that applies the
		incoming rowops to the table. 
		</listitem>
		<listitem>
		The output label propagates the
		modifications done to the table. It is a dummy label, and does
		nothing by itself. It's there for chaining the other labels to it. The
		output rowop comes quite handy to propagate the table's modifications
		to the rest of the state.
		</listitem>
		<indexterm>
			<primary>tracing</primary>
		</indexterm>
		<listitem>
		The pre-modification label is also a dummy label, for chaining other
		labels to it. It sends the rowops right before they are applied
		to the table. This comes very handy for the elements that need to
		act depending on the previous state of the table, such as joins.
		The pre-modification label doesn't simply mirror the input label.
		The rows received on the input label may trigger the automatic changes
		to the table, such as an old row being deleted when a new row with
		the same key is inserted. All these modifications, be they automatic
		or explicit, will be reported to the pre-modification label.
		Since the pre-modification label is used relatively rarely, it contains
		a special optimization: if there is no label chained to it, no rowop
		will be sent to it in the first place. Don't be surprised if you
		enable the tracing and don't see it in the trace.
		</listitem>
		</itemizedlist>

		<para>
		Again, the rowops coming through these labels aren't necessarily
		the same. If a DELETE rowop comes to the input label, referring to a
		row that is not in the table, it will not propagate anywhere. If an INSERT rowop
		comes in and causes another row to be replaced, the replaced row will
		be sent to the pre-modification and output labels as a DELETE rowop first.
		</para>

		<para>
		Anf of course the table may be modified through the procedural
		interface. These modifications also produce rowops on the
		pre-modification and output labels.
		</para>

		<para>
		The labels of the table have names. They are produced by adding
		suffixes to the table name. They are "tablename.in", "tablename.pre"
		and "tablename.out".
		</para>

		<indexterm>
			<primary>scheduling</primary>
			<secondary>recursion</secondary>
		</indexterm>
		<indexterm>
			<primary>recursion</primary>
		</indexterm>
		<indexterm>
			<primary>schedule</primary>
			<secondary>loop</secondary>
		</indexterm>
		<para>
		In the <quote>no bundling</quote> spirit, a rowop is sent to the pre-modification
		label right before it's applied to the table, and to the output label
		right after it's applied. If the labels executed from there need to read the table,
		they can, and will find the table in the exact state with no intervening
		modifications. However, they can't modify the table neither directly nor
		by calling its input label. When these labels are called, the table is in
		the middle of a modification and it can't accept another one. Such attempts
		are treated as recursive modifications, forbidden, and the program 
		will die on them. If you need to modify
		the table, use <pre>schedule()</pre> or <pre>loopAt()</pre> to have the next modification done
		later. However there are no guarantees about other modifications getting
		done in between. When the looped rowop executes, it might need to check the state
		of the table again and decide if its operation still makes sense.
		</para>

		<para>
		So, let's make a version of <quote>Hello, table</quote> example that passes the
		modification requests as rowops through the labels. It will print the information about
		the updates to the table as they happen, so there is no more use having a
		separate command for that. But for another demonstration let's add a
		command that would clear the counter of hellos.  Here is its code:
		</para>

<!-- t/xHelloTable.t helloWorldLabels shifted left -->
<pre>
my $hwunit = Triceps::Unit->new("hwunit") or confess "$!";
my $rtCount = Triceps::RowType->new(
	address => "string",
	count => "int32",
) or confess "$!";

my $ttCount = Triceps::TableType->new($rtCount)
	->addSubIndex("byAddress", 
		Triceps::IndexType->newHashed(key => [ "address" ])
	)
or confess "$!";
$ttCount->initialize() or confess "$!";

my $tCount = $hwunit->makeTable($ttCount, "EM_CALL", "tCount") or confess "$!";

my $lbPrintCount = $hwunit->makeLabel($tCount->getRowType(),
	"lbPrintCount", undef, sub { # (label, rowop)
		my ($label, $rowop) = @_;
		my $row = $rowop->getRow();
		&send(&Triceps::opcodeString($rowop->getOpcode), " '", 
			$row->get("address"), "', count ", $row->get("count"), "\n");
	} ) or confess "$!";
$tCount->getOutputLabel()->chain($lbPrintCount) or confess "$!";

# the updates will be sent here, for the tables to process
my $lbTableInput = $tCount->getInputLabel();

while(&readLine) {
	chomp;
	my @data = split(/\W+/);

	# the common part: find if there already is a count for this address
	my $rhFound = $tCount->findBy(
		address => $data[1]
	);
	my $cnt = 0;
	if (!$rhFound->isNull()) {
		$cnt = $rhFound->getRow()->get("count");
	}

	if ($data[0] =~ /^hello$/i) {
		$hwunit->makeHashSchedule($lbTableInput, "OP_INSERT",
			address => $data[1],
			count => $cnt+1,
		);
	} elsif ($data[0] =~ /^clear$/i) {
		$hwunit->makeHashSchedule($lbTableInput, "OP_DELETE",
			address => $data[1]
		);
	} else {
		&send("Unknown command '$data[0]'\n");
	}
	$hwunit->drainFrame();
}
</pre>

		<para>
		The table creation is the same as last time. The only difference is that
		it uses <pre>"EM_CALL"</pre> instead of <pre>&Triceps::EM_CALL</pre>, both being equivalent.
		The row finding in the table is also the same.
		</para>

		<para>
		The printing of the modifications to the table is done with <pre>$lbPrintCount</pre>,
		which is connected to the table's output label. It prints the opcode,
		the address of the greeting, and the count of greetings. It will
		show us what is happening to the table as soon as it happens.
		An unit trace could be used instead but a custom printout contains
		less noise.
		The pre-modification label is of no interest here, so it's not used.
		</para>

		<para>
		The references to the labels of a table are gotten with:
		</para>

<pre>
$label = $table->getInputLabel();
$label = $table->getPreLabel();
$label = $table->getOutputLabel();
</pre>

		<para>
		The deletion does not require an exact row to be sent in. All it needs
		is a row with the keys for deletion, the rest of the fields in it
		are ignored. So the <quote>clear</quote> command puts only the key field in it.
		</para>

		<para>
		Here is an example of input (in italics) and output:
		</para>

<exdump>
> Hello, table!
OP_INSERT 'table', count 1
> Hello, world!
OP_INSERT 'world', count 1
> Hello, table!
OP_DELETE 'table', count 1
OP_INSERT 'table', count 2
> clear, table
OP_DELETE 'table', count 2
> Hello, table!
OP_INSERT 'table', count 1
</exdump>

		<para>
		An interesting thing happens after the second <quote>Hello, table!</quote>: the code
		send only an <pre>OP_INSERT</pre> but the output shows an <pre>OP_DELETE</pre> and <pre>OP_INSERT</pre>.
		The <pre>OP_DELETE</pre> for the old row gets automatically generated when a
		row with repeated key is inserted. 
		Now, depending on what you want, just sending in the first place the consequent inserts of
		rows with the same keys, and relying on the table's internal
		consistency to turn them into updates, might be a good thing or not.
		Overall it's a dirty way to write but sometimes it comes convenient.
		The clean way is to send the explicit deletes first. When the data
		goes through the table, it gets automatically cleaned.
		The subscribers to the table's output and pre-modification labels
		get the clean and consistent picture: a row never gets simply replaced, they
		always see an <pre>OP_DELETE</pre> first and only then an <pre>OP_INSERT</pre>.
		</para>
	</sect1>

	<sect1 id="sc_table_iteration">
		<title>Basic iteration through the table</title>

		<para>
		Let's add a dump of the table contents to the "Hello, table" example,
		either version of it. For that, the code needs to go through every record
		in the table:
		</para>

<!-- t/xHelloTable.t helloWorldDirect fragment, shifted left -->
<pre>
	elsif ($data[0] =~ /^dump$/i) {
		for (my $rhi = $tCount->begin(); !$rhi->isNull(); $rhi = $rhi->next()) {
			&send($rhi->getRow->printP(), "\n");
		}
	}
</pre>

		<indexterm>
			<primary>table</primary>
			<secondary>iteration</secondary>
		</indexterm>
		<para>
		As you can see, the row handle works kind of like an STL iterator.
		Only the end of iteration is detected by receiving a NULL row handle.
		Calling <pre>next()</pre> on a NULL row handle is OK but it would just return
		another NULL handle.
		And there is no decrementing the iterator, you can only go forward
		with <pre>next()</pre>. The backwards iteration is in the plans but
		not implemented yet.
		</para>

		<para>
		An example of this fragment's output would be:
		</para>

<!-- t/xHelloTable.t helloWorldDirect fragment, removed backslashes -->
<exdump>
> Hello, table!
> Hello, world!
> Hello, table!
> count world
Received 'world' 1 times
> Count table
Received 'table' 2 times
> dump
address="world" count="1" 
address="table" count="2" 
</exdump>

		<para>
		The order of the rows in the printout is the same as the order of rows
		in the table's index. Which is no particular order, since it's a hashed
		index. As long as you stay with the same 64-bit AMD64 architecture
		(with LSB-first byte order), it will stay the same on consecutive runs.
		But switching to a 32-bit machine or to an MSB-first byte order (such
		as a SPARC, if you can still find one) will change the hash
		calculation, and with it the resulting row order. There are the
		ordered indexes as well, they will be described later.
		</para>
	</sect1>

	<sect1 id="sc_table_delete">
		<title>Deleting a row</title>

		<para>
		Deleting a row from a table through the input label is simple: send a
		rowop with <pre>OP_DELETE</pre>, it will find the row with the matching key 
		and delete it, as was shown above.
		In the procedural way the same can be done with the method
		<pre>deleteRow()</pre>. The added row deletion code for the main loop of 
		<quote>Hello, table</quote> (either version, but particularly relevant
		for the one from
		<xref linkend="sc_table_hello" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;)
		is:
		</para>

<!-- t/xHelloTable.t helloWorldDirect fragment, shifted left -->
<pre>
	elsif ($data[0] =~ /^delete$/i) {
		my $res = $tCount->deleteRow($rtCount->makeRowHash(
			address => $data[1],
		));
		&send("Address '", $data[1], "' is not found\n") unless $res;
	}
</pre>

		<indexterm>
			<primary>error handling</primary>
		</indexterm>
		<indexterm>
			<primary>table</primary>
			<secondary>procedural API</secondary>
		</indexterm>
		<indexterm>
			<primary>table</primary>
			<secondary>remove</secondary>
		</indexterm>
		<para>
		The result allows to differentiate between the situations when the 
		row was found and deleted and the row was not found.
		On any error the call confesses. The <pre>insert()</pre> method also
		follows this new convention and confesses on errors.
		</para>

		<para>
		However we already find the row handle in advance in <pre>$rhFound</pre>. For this case a more
		efficient form is available, and it can be added to the example as:
		</para>

<!-- t/xHelloTable.t helloWorldDirect fragment, shifted left -->
<pre>
		elsif ($data[0] =~ /^remove$/i) {
			if (!$rhFound->isNull()) {
				$tCount->remove($rhFound);
			} else {
				&send("Address '", $data[1], "' is not found\n");
			}
		}
</pre>

		<para>
		It removes a specific row handle from the table. In whichever way you
		find it, you can remove it. An attempt to remove a NULL handle would be
		an error (and this method also confesses on errors).
		</para>

		<para>
		The reason why <pre>remove()</pre> is more efficient than <pre>deleteRow()</pre> is
		that <pre>deleteRow()</pre> amounts to finding the row handle by key and then
		removing it. And the <pre>OP_DELETE</pre> rowop sent to the input label
		calls <pre>deleteRow()</pre>.
		</para>

		<para>
		<pre>deleteRow()</pre> never deletes more than one row, even if multiple
		rows match (yes, the indexes don't have to be unique).
		There isn't any method to delete multiple rows at once. Every row has
		to be deleted by itself.
		As an example, here is the implementation of the command <quote>clear</quote> for
		<quote>Hello, table</quote> that clears all the table contents by
		iterating through it:
		</para>

<!-- t/xHelloTable.t helloWorldDirect fragment, shifted left -->
<pre>
	elsif ($data[0] =~ /^clear$/i) {
		my $rhi = $tCount->begin(); 
		while (!$rhi->isNull()) {
			my $rhnext = $rhi->next();
			$tCount->remove($rhi);
			$rhi = $rhnext;
		}
	}
</pre>

		<indexterm>
			<primary>table</primary>
			<secondary>iteration</secondary>
		</indexterm>
		<para>
		After a handle is removed from the table, it continues to exist, as
		long as there are references to it. It could even be inserted back into
		the table. However until (and unless) it's inserted back, it can not be
		used for iteration any more. Calling <pre>next()</pre> on a handle that
		is not in the table would just return a NULL handle. So the next row has
		to be found before removing the current one.
		</para>
	</sect1>

	<sect1 id="sc_table_RowHandle">
		<title>A closer look at the RowHandles</title>

		<indexterm>
			<primary>RowHandle</primary>
		</indexterm>
		<para>
		A few uses of the RowHandles have been shown by now. So, what is a
		RowHandle? As Captain Obvious would say, RowHandle is a class (or
		package, in Perl terms) implementing a row handle.
		</para>

		<para>
		A RowHandle keeps a table's service information (including the index
		data) for a single data row, including of course a reference to the row
		itself. Each row is stored in the table through its handle. A RowHandle
		always belongs to a particular table, the RowHandles can not be shared
		nor moved between two tables, even if the tables are of the same type.
		Since the tables are single-threaded, obviously the RowHandles may not
		be shared between the threads either.
		</para>

		<para>
		However a RowHandle may exist without being inserted into a table. In
		this case it still has a spiritual connection to that table but is not
		included in the index, and will be destroyed as soon as all the
		references to it disappear.
		</para>

		<para>
		The insertion of a row into a table actually happens in two steps:
		</para>

		<orderedlist>
		<listitem>
		A RowHandle is created for a row.
		</listitem>
		<listitem>
		This new handle is inserted into the table.
		</listitem>
		</orderedlist>

		<para>
		This is done with the following code:
		</para>

<pre>
$rh = $table->makeRowHandle($row) or confess "$!";
$table->insert($rh);
</pre>

		<indexterm>
			<primary>table</primary>
			<secondary>insert</secondary>
		</indexterm>
		<para>
		Only it just so happens that to make life easier, the method
		<pre>insert()</pre> has been made to accept either a row handle or
		directly a row. If it finds a row, it makes a handle for it behind the
		curtains and then proceeds with the insertion of that handle. Passing a
		row directly is also more efficient (if you don't have a handle already
		created for it for some other reason) because the row handle creation
		then happens entirely in the &Cpp; code, without surfacing into Perl.
		</para>

		<para>
		A handle can be created for any row of a type matching the table's
		row type. For a while it was accepting only equal types but that
		was not consistent with what the labels are doing, so I've changed it.
		</para>

		<indexterm>
			<primary>error handling</primary>
		</indexterm>
		<para>
		The method <pre>insert()</pre> has a return value. It's often ignored but occasionally
		comes handy.  1 means that the row has been inserted successfully, and
		0 means that the row has been rejected. On errors it confesses.
		An attempt to insert a NULL handle or a handle that is already in the
		table will cause a rejection, not an error.
		Also the table's index may reject a row with duplicate key (though
		right now this option is not implemented, and the hash index silently
		replaces the old row with the new one).
		</para>

		<para>
		There is a method to find out if a row handle is in the table or not:
		</para>

<pre>
$result = $rh->isInTable();
</pre>

		<para>
		Though it's used mostly for debugging, when some strange things start going on.
		</para>

		<indexterm>
			<primary>table</primary>
			<secondary>find</secondary>
		</indexterm>
		<para>
		The searching for rows in the table by key has been previously shown with the
		method <pre>findBy()</pre>. Which happens to be a wrapper over a more general method
		<pre>find()</pre>: it constructs a row from its argument fields and then calls
		<pre>find()</pre> with that row as a sample of data to find.
		The method <pre>find()</pre> is similar to <pre>insert()</pre> in the
		handling of its arguments: the <quote>proper</quote> way is to give
		it a row handle argument, but the more efficient way is to give it a 
		row argument, and it will create the handle for it as needed before
		performing a search.
		</para>

		<para>
		Now you might wonder: huh, <pre>find()</pre> takes a row handle and returns a row
		handle? What's the point? Why not just use the first row handle? Well,
		those are different handles:
		</para>

		<itemizedlist>
		<listitem>
		The argument handle is normally not in the table. It's created brand
		new from a row that contains the keys that you want to find, just for
		the purpose of searching.
		</listitem>
		<listitem>
		The returned handle is always in the table (of course, unless it's
		NULL). It can be further used to extract back the row data, and/or for
		iteration.
		</listitem>
		</itemizedlist>

		<para>
		Though nothing really prevents you from searching for a handle that is
		already in the table. You'll just get back the same handle, after
		gratuitously spending some CPU time. (There are exceptions to this,
		with the more complex indexes that will be described later).
		</para>

		<para>
		Why do you need to create new a row handle just for the search? Due to
		the internal mechanics of the implementation. A handle stores the
		helper information for the index. For example, the hash index
		calculates the hash value of all the row's key fields once and
		stores it in the row handle. Despite it being called a hash index, it
		really stores the data in a tree, with the hash value used to speed up
		the comparisons for the tree order. It's much easier to make both the
		<pre>insert()</pre> and <pre>find()</pre> work with the hash value and row reference
		stored in the same way in a handle than to implement them differently. Because of
		this, <pre>find()</pre> uses the exactly same row handle argument format as
		<pre>insert()</pre>.
		</para>

		<para>
		Can you create multiple row handles referring to the same row? Sure,
		knock yourself out. From the table's perspective it's the same thing as
		multiple row handles for multiple copies of the row with the same values
		in them, only using less memory.
		</para>

		<para>
		There is more to the row handles than has been touched upon yet. It
		will all be revealed when more of the table features are described.
		</para>
	</sect1>

	<sect1 id="sc_table_fifo">
		<title>A window is a FIFO</title>

		<indexterm>
			<primary>window</primary>
		</indexterm>
		<indexterm>
			<primary>FIFO</primary>
		</indexterm>

		<para>
		A fairly typical situation in the CEP world is when a model needs to
		keep a limited history of events. For a simple example, let's discuss,
		how to remember the last two trades per stock symbol. The size of two
		has been chosen to keep the sample input and outputs small.
		</para>

		<para>
		This is normally called a window logic, with a sliding window. You can
		think of it in a mechanical analogy: as the trades become available,
		they get printed on a long tape. However the tape is covered with a
		masking plate. The plate has a window cut in it that lets you see only
		the last two trades.
		</para>

		<indexterm>
			<primary>Coral8</primary>
		</indexterm>
		<para>
		Some CEP systems have the special data structures that implement this
		logic, that are called windows. Triceps has a feature on a table
		instead that makes a table work as a window. It's not unique in this
		department: for example Coral8 does the opposite, calls everything a
		window, even if some windows are really tables in every regard but
		name.
		</para>

		<para>
		Here is a Triceps example of keeping the window for the last two trades
		and iteration over it:
		</para>

<!-- t/xWindow.t doWindow -->
<pre>
our $uTrades = Triceps::Unit->new("uTrades") or confess "$!";
our $rtTrade = Triceps::RowType->new(
	id => "int32", # trade unique id
	symbol => "string", # symbol traded
	price => "float64",
	size => "float64", # number of shares traded
) or confess "$!";

our $ttWindow = Triceps::TableType->new($rtTrade)
	->addSubIndex("bySymbol", 
		Triceps::IndexType->newHashed(key => [ "symbol" ])
			->addSubIndex("last2",
				Triceps::IndexType->newFifo(limit => 2)
			)
	)
	or confess "$!";
$ttWindow->initialize() or confess "$!";
our $tWindow = $uTrades->makeTable($ttWindow, 
	&Triceps::EM_CALL, "tWindow") or confess "$!";

# remember the index type by symbol, for searching on it
our $itSymbol = $ttWindow->findSubIndex("bySymbol") or confess "$!";
# remember the FIFO index, for finding the start of the group
our $itLast2 = $itSymbol->findSubIndex("last2") or confess "$!";

# print out the changes to the table as they happen
our $lbWindowPrint = $uTrades->makeLabel($rtTrade, "lbWindowPrint",
	undef, sub { # (label, rowop)
		&send($_[1]->printP(), "\n"); # print the change
	}) or confess "$!";
$tWindow->getOutputLabel()->chain($lbWindowPrint) or confess "$!";

while(&readLine) {
	chomp;
	my $rTrade = $rtTrade->makeRowArray(split(/,/)) or confess "$!";
	my $rhTrade = $tWindow->makeRowHandle($rTrade) or confess "$!";
	$tWindow->insert($rhTrade);
	# There are two ways to find the first record for this
	# symbol. Use one way for the symbol AAA and the other for the rest.
	my $rhFirst;
	if ($rTrade->get("symbol") eq "AAA") {
		$rhFirst = $tWindow->findIdx($itSymbol, $rTrade) or confess "$!";
	} else  {
		# $rhTrade is now in the table but it's the last record
		$rhFirst = $rhTrade->firstOfGroupIdx($itLast2) or confess "$!";
	}
	my $rhEnd = $rhFirst->nextGroupIdx($itLast2) or confess "$!";
	&send("New contents:\n");
	for (my $rhi = $rhFirst; 
			!$rhi->same($rhEnd); $rhi = $rhi->nextIdx($itLast2)) {
		&send("  ", $rhi->getRow()->printP(), "\n");
	}
}
</pre>

		<para>
		This example reads the trade records in CSV format, inserts them into
		the table, and then prints the actual modifications reported by the
		table and the new state of the window for this symbol. And here is a sample
		log, with the input lines in italics:
		</para>

<exdump>
> 1,AAA,10,10
tWindow.out OP_INSERT id="1" symbol="AAA" price="10" size="10" 
New contents:
  id="1" symbol="AAA" price="10" size="10" 
> 2,BBB,100,100
tWindow.out OP_INSERT id="2" symbol="BBB" price="100" size="100" 
New contents:
  id="2" symbol="BBB" price="100" size="100" 
> 3,AAA,20,20
tWindow.out OP_INSERT id="3" symbol="AAA" price="20" size="20" 
New contents:
  id="1" symbol="AAA" price="10" size="10" 
  id="3" symbol="AAA" price="20" size="20" 
> 4,BBB,200,200
tWindow.out OP_INSERT id="4" symbol="BBB" price="200" size="200" 
New contents:
  id="2" symbol="BBB" price="100" size="100" 
  id="4" symbol="BBB" price="200" size="200" 
> 5,AAA,30,30
tWindow.out OP_DELETE id="1" symbol="AAA" price="10" size="10" 
tWindow.out OP_INSERT id="5" symbol="AAA" price="30" size="30" 
New contents:
  id="3" symbol="AAA" price="20" size="20" 
  id="5" symbol="AAA" price="30" size="30" 
> 6,BBB,300,300
tWindow.out OP_DELETE id="2" symbol="BBB" price="100" size="100" 
tWindow.out OP_INSERT id="6" symbol="BBB" price="300" size="300" 
New contents:
  id="4" symbol="BBB" price="200" size="200" 
  id="6" symbol="BBB" price="300" size="300" 
</exdump>

		<para>
		You can see that the window logic works: at no time is there
		more than two rows in each group. As more rows are inserted,
		the oldest rows get deleted.
		</para>

		<indexterm>
			<primary>type</primary>
			<secondary>table</secondary>
		</indexterm>
		<indexterm>
			<primary>type</primary>
			<secondary>index</secondary>
		</indexterm>
		<para>
		Now let's dig into the code.
		The first thing to notice is that the table type has two
		indexes (strictly speaking, index types, but most of the time
		they can be called indexes without creating a confusion) in it. Unlike
		your typical database, the indexes in this example are nested.
		</para>

<pre>
TableType
+-IndexType Hash "bySymbol"
  +-IndexType Fifo "last2"
</pre>

		<para>
		If you follow the nesting, you can see, that the first call <pre>addSubIndex()</pre>
		adds an index type to the table type, while the textually second
		<pre>addSubIndex()</pre> adds an index to the previous index.
		</para>

		<para>
		The same can also be written out in multiple separate calls,
		with the intermediate results stored in the variables:
		</para>

<pre>
$itLast2 = Triceps::IndexType->newFifo(limit => 2);
$itSymbol = Triceps::IndexType->newHashed(key => [ "symbol" ]);
$itSymbol->addSubIndex("last2", $itLast2);
$ttWindow = Triceps::TableType->new($rtTrade);
$ttWindow->addSubIndex("bySymbol", $itSymbol);
</pre>

		<para>
		I'm not perfectly happy with the way the table types are constructed
		with the index types right now, since the parenthesis levels have
		turned out a bit hard to track. This is another example of following
		the &Cpp; API in Perl that didn't work out too well, and it will change
		in the future. But for now please bear with it.
		</para>

		<para>
		The index nesting is kind of intuitively clear, but the details may
		take some time to get your head wrapped around them. You can think of
		it as the inner index type creating the miniature tables that hold the
		rows, and then the outer index holding not individual rows but those
		miniature tables. So, to find the rows in the table you go through two
		levels of indexes: first through the outer index, and then through the
		inner one. The table takes care of these details and makes them
		transparent, unless you want to stop your search at an intermediate
		level: such as, to find <i>all</i> the transactions with a given
		symbol, you need to do a search in the outer index, but then from that
		point iterate through all rows in the found inner index. For this you
		obviously have to tell the table, where do you want to stop in
		the search.
		</para>

		<indexterm>
			<primary>index</primary>
			<secondary>FIFO</secondary>
		</indexterm>
		<para>
		The outer index is the hash index that we've seen before, the inner
		index is a FIFO index. A FIFO index doesn't have any key, it just keeps
		the rows in the order they were inserted. You can search in a FIFO
		index but most of the time it's not the best idea: since it has no
		keys, it searches linearly through all its rows until it finds an exact
		match (or runs out of rows). It's a reasonable last-resort way but it's
		not fast and in many cases not what you want. This also sends
		a few ripples through the row deletion. Remember that the method
		<pre>deleteRow()</pre> and sending the <pre>OP_DELETE</pre> to the table's input label invoke
		<pre>find()</pre>, which would cause the linear search on the FIFO indexes. So
		when you use a FIFO index, it's usually better to find the row handle
		you want to delete in some other way and then call <pre>remove()</pre> on it, or
		use another approach that will be shown later. Or just keep inserting
		the rows and never delete them, like this example does.
		</para>

		<para>
		A FIFO index may contain multiple copies of an exact same
		row. It doesn't care, it just keeps whatever rows were given to it in
		whatever order they were given. 
		</para>

		<para>
		By default a FIFO index just keeps whatever rows come to it. However it
		may have a few options. Setting the option <pre>limit</pre> limits the number of
		rows stored in the index (not per the whole table but per one of those
		<quote>miniature tables</quote>). When you try to insert one row too many, the oldest
		row gets thrown out, and the limit stays unbroken. That's what creates
		the window behavior: keep the most recent N rows.
		</para>

		<para>
		If you look at the sample output, you can see that inserting the rows
		with ids 1-4 generates only the insert events on the table. But the
		rows 5 and 6 start overflowing their FIFO indexes, and cause the oldest
		row to be automatically deleted before completing the insert of the new
		one.
		</para>

		<para>
		A FIFO index doesn't have to be nested inside a hash index. If you put
		a FIFO index at the top level, it will control the whole table. So it
		would be not two last record per key but two last records inserted in the
		whole table.
		</para>

		<indexterm>
			<primary>index</primary>
			<secondary>initialization</secondary>
		</indexterm>
		<indexterm>
			<primary>type</primary>
			<secondary>index</secondary>
		</indexterm>
		<para>
		Continuing with the example, the table gets created, and then the index
		types get extracted back from the table type. Now, why not just write
		out the table type creation with intermediate variables 
		as shown above and remember the index
		references? At some point in the past this actually would have worked
		but not any more. It has to do with the way the table type and its
		index types are connected. It's occasionally convenient to create one
		index type and then reuse it in multiple table types. However for the
		whole thing to work, the index type must be tied to its particular
		table type. This tying together happens when the table type is
		initialized. If you put the same index type into two table types, then when
		the first table type is initialized, the index type will get tied to
		it. The second table type would then fail to initialize because an
		index in it is already tied elsewhere. To get around this
		dilemma, now when you call <pre>addSubIndex()</pre>, it doesn't connect the
		original index type, instead it makes a copy of it. That copy then gets
		tied with the table type and later gets returned back with <pre>findSubIndex()</pre>.
		</para>

		<para>
		The table methods that take an index type argument
		absolutely require that the index type must be tied to that table's type. If
		you try to pass a seemingly the same index type that has not been tied,
		or has been tied to a different table type, that is an error. 
		</para>

		<para>
		One last note on this subject: there is
		no interdependency between the methods <pre>makeTable()</pre> and <pre>findSubIndex()</pre>,
		they can be done in either order.
		</para>

		<para>
		The example output comes from two sources. The running updates on the table's
		modifications (the lines with <pre>OP_INSERT</pre> and <pre>OP_DELETE</pre>) are printed from the label
		<pre>$lbWindowPrint</pre>. The new window contents is printed from the main loop.
		</para>

		<para>
		The main loop reads the trade records in the simple
		CSV format without the opcode, and for simplicity inserts directly 
		into the table with the procedural API, bypassing
		the scheduler. After the row is inserted, the contents of its index
		group (that <quote>miniature table</quote>) gets printed. The insertion could as
		well have been done with passing directly the row reference, without
		explicitly creating a handle. But that handle will be used to
		demonstrate an interesting point.
		</para>

		<indexterm>
			<primary>table</primary>
			<secondary>iteration</secondary>
		</indexterm>
		<indexterm>
			<primary>index</primary>
			<secondary>group</secondary>
		</indexterm>
		<para>
		To print the contents of an index group, we need to find its
		boundaries. In Triceps these boundaries are expressed as the first row
		handle of the group, and as the row handle right after the group. There
		is an internal logic to that, and it will be explained later, but for
		now just take it on faith.
		</para>

		<para>
		With the information we have, there are two ways to find the first row of the group:
		</para>

		<indexterm>
			<primary>table</primary>
			<secondary>find</secondary>
		</indexterm>
		<indexterm>
			<primary>index</primary>
			<secondary>find</secondary>
		</indexterm>
		<itemizedlist>
		<listitem>
		With the table's method <pre>findIdx()</pre>. It's very much like <pre>find()</pre>, only it
		has an extra argument of a specific index type. If the index type given
		has no further nesting in it, <pre>findIdx()</pre> works exactly like <pre>find()</pre>. In
		fact, <pre>find()</pre> is exactly such a special case of <pre>findIdx()</pre> with an
		automatically chosen index type. If you use an index type with further nesting
		under it, <pre>findIdx()</pre> will return the handle of the first row in the
		group under it (or the usual NULL row handle if not found).
		</listitem>
		<indexterm>
			<primary>RowHandle</primary>
		</indexterm>
		<listitem>
		If we create the row handle explicitly before inserting it into the
		table, as was done in the example, that will be the exact row handle
		inserted into the table. Not a copy or anything but this particular row
		handle. After a row handle gets inserted into the table, it knows its
		position in the indexes. It knows, in which group it is.
		And we still have a reference to it. So then
		we can use this knowledge to navigate within the group, 
		jump to the first row handle in the group
		with <pre>firstOfGroupIdx()</pre>. It also takes an index type but in this case
		it's the type that controls the group, the FIFO index in out case.
		</listitem>
		</itemizedlist>

		<para>
		The example shows both ways. As a demonstration, it uses the first way
		if the symbol is <quote>AAA</quote> and the second way for all the other symbols.
		</para>

		<indexterm>
			<primary>table</primary>
			<secondary>iteration</secondary>
		</indexterm>
		<para>
		The end boundary is found by calling <pre>nextGroupIdx()</pre> on the first row's
		handle. The handle of the newly inserted row could have also been used for
		<pre>nextGroupIdx()</pre>, or any other handle in the group. For any
		handle belonging to the same group, the result is exactly the same.
		</para>

		<para>
		And finally, after the iteration boundaries have been found,
		the iteration on the group can run. The end
		condition comparison is done with <pre>same()</pre>, to compare the row
		handle references and not just their Perl-level wrappers. The stepping
		is done with <pre>nextIdx()</pre>, with is exactly like <pre>next()</pre> but according to a
		particular index, the FIFO one. This has actually been done purely to
		show off this method. In this particular case the result produced by
		<pre>next()</pre>, <pre>nextIdx()</pre> on the FIFO index type and <pre>nextIdx()</pre> on 
		the outer hash index type is exactly the same. We'll come to the reasons of
		that yet.
		</para>

		<indexterm>
			<primary>aggregation</primary>
		</indexterm>
		<para>
		Looking forward, as you iterate through the group, you could do some manual aggregation
		along the way. For example, find the average price of the last two
		trades, and then do something useful with it.
		</para>
	</sect1>

	<sect1 id="sc_table_secondary">
		<title>Secondary indexes</title>

		<para>
		The last example dealt only with the row inserts, because it could not
		handle the deletions that well. What if the trades may get cancelled
		and have to be removed from the table? There is a solution to this
		problem: add one more index. Only this time not nested but in parallel.
		The indexes in the table type become tree-formed:
		</para>

		<indexterm>
			<primary>index</primary>
			<secondary>hashed</secondary>
		</indexterm>
		<indexterm>
			<primary>index</primary>
			<secondary>secondary</secondary>
		</indexterm>
		<indexterm>
			<primary>index</primary>
			<secondary>tree</secondary>
		</indexterm>
<pre>
TableType
+-IndexType Hash "byId" (id)
+-IndexType Hash "bySymbol" (symbol)
  +-IndexType Fifo "last2"
</pre>

		<para>
		It's very much like the common relational databases where you can
		define multiple indexes on the same table. Both indexes <pre>byId</pre> and
		<pre>bySymbol</pre> (together with its nested sub-index) refer to the same
		set of rows stored in the table. Only <pre>byId</pre> allows to easily find
		the records by the unique id, while <pre>bySymbol</pre> is responsible for
		keeping then grouped by the symbol, in FIFO order. It could be said
		that <pre>byId</pre> is the primary index (since it has a unique key) and
		<pre>bySymbol</pre> is a secondary one (since it does the grouping) but
		from the Triceps'es standpoint they are pretty much equal and parallel
		to each other.
		</para>

		<indexterm>
			<primary>aggregation</primary>
		</indexterm>
		<para>
		To illustrate the point, here is a modified version of the previous
		example. Not only does it manage the deletes but also computes the
		average price of the collected transactions as it iterates through
		the group, thus performing a manual aggregation.
		</para>

<!-- t/xWindow.t doSecondary -->
<pre>
our $uTrades = Triceps::Unit->new("uTrades") or confess "$!";
our $rtTrade = Triceps::RowType->new(
	id => "int32", # trade unique id
	symbol => "string", # symbol traded
	price => "float64",
	size => "float64", # number of shares traded
) or confess "$!";

our $ttWindow = Triceps::TableType->new($rtTrade)
	->addSubIndex("byId", 
		Triceps::IndexType->newHashed(key => [ "id" ])
	)
	->addSubIndex("bySymbol", 
		Triceps::IndexType->newHashed(key => [ "symbol" ])
			->addSubIndex("last2",
				Triceps::IndexType->newFifo(limit => 2)
			)
	)
	or confess "$!";
$ttWindow->initialize() or confess "$!";
our $tWindow = $uTrades->makeTable($ttWindow, 
	&Triceps::EM_CALL, "tWindow") or confess "$!";

# remember the index type by symbol, for searching on it
our $itSymbol = $ttWindow->findSubIndex("bySymbol") or confess "$!";
# remember the FIFO index, for finding the start of the group
our $itLast2 = $itSymbol->findSubIndex("last2") or confess "$!";

# remember, which was the last row modified
our $rLastMod;
our $lbRememberLastMod = $uTrades->makeLabel($rtTrade, "lbRememberLastMod",
	undef, sub { # (label, rowop)
		$rLastMod = $_[1]->getRow();
	}) or confess "$!";
$tWindow->getOutputLabel()->chain($lbRememberLastMod) or confess "$!";

# Print the average price of the symbol in the last modified row
sub printAverage # (row)
{
	return unless defined $rLastMod;
	my $rhFirst = $tWindow->findIdx($itSymbol, $rLastMod) or confess "$!";
	my $rhEnd = $rhFirst->nextGroupIdx($itLast2) or confess "$!";
	&send("Contents:\n");
	my $avg;
	my ($sum, $count);
	for (my $rhi = $rhFirst; 
			!$rhi->same($rhEnd); $rhi = $rhi->nextIdx($itLast2)) {
		&send("  ", $rhi->getRow()->printP(), "\n");
		$count++;
		$sum += $rhi->getRow()->get("price");
	}
	if ($count) {
		$avg = $sum/$count;
	}
	&send("Average price: ", (defined $avg? $avg: "Undefined"), "\n");
}

while(&readLine) {
	chomp;
	my @data = split(/,/);
	my $op = shift @data; # string opcode, if incorrect then will die later
	my $rTrade = $rtTrade->makeRowArray(@data) or confess "$!";
	my $rowop = $tWindow->getInputLabel()->makeRowop($op, $rTrade) 
		or confess "$!";
	$uTrades->call($rowop) or confess "$!";
	&printAverage();
	undef $rLastMod; # clear for the next iteration
	$uTrades->drainFrame(); # just in case, for completeness
}
</pre>

		<para>
		And an example of its work, with the input lines shown in italics:
		</para>

<exdump>
> OP_INSERT,1,AAA,10,10
Contents:
  id="1" symbol="AAA" price="10" size="10" 
Average price: 10
> OP_INSERT,2,BBB,100,100
Contents:
  id="2" symbol="BBB" price="100" size="100" 
Average price: 100
> OP_INSERT,3,AAA,20,20
Contents:
  id="1" symbol="AAA" price="10" size="10" 
  id="3" symbol="AAA" price="20" size="20" 
Average price: 15
> OP_INSERT,4,BBB,200,200
Contents:
  id="2" symbol="BBB" price="100" size="100" 
  id="4" symbol="BBB" price="200" size="200" 
Average price: 150
> OP_INSERT,5,AAA,30,30
Contents:
  id="3" symbol="AAA" price="20" size="20" 
  id="5" symbol="AAA" price="30" size="30" 
Average price: 25
> OP_INSERT,6,BBB,300,300
Contents:
  id="4" symbol="BBB" price="200" size="200" 
  id="6" symbol="BBB" price="300" size="300" 
Average price: 250
> OP_DELETE,3
Contents:
  id="5" symbol="AAA" price="30" size="30" 
Average price: 30
> OP_DELETE,5
Contents:
Average price: Undefined
</exdump>

		<para>
		The input has changed: now an extra column is prepended to it,
		containing the opcode for the row. The updates to the table are not
		printed any more, but the calculated average price is printed after the
		new contents of the group.
		</para>

		<para>
		In the code, the first obvious addition is the extra index in the table
		type. The label that used to print the updates is gone, and replaced
		with another one, that remembers the last modified row in a global
		variable.
		</para>

		<para>
		That last modified row is then used in the function <pre>printAverage()</pre>
		to find the group for iteration.
		Why? Could not we just remember the symbol from the input data? Not always.
		As you can see from the last two input rows with <pre>OP_DELETE</pre>, the
		trade id is the only field required to find and delete a row using the
		index <pre>byId</pre>. So these trade cancellation rows take a shortcut and
		only provide the trade id, not the rest of the fields. If we try to
		remember the symbol fields from them, we'd remember an <pre>undef</pre>.
		Can we just look up the row by id after the incoming rowop has been processed?
		Not after the deletion.
		If we try to find the symbol by looking up the row
		after the deletion, we will find nothing, because the row will already
		be deleted. We could look up the row in the table before the deletion,
		and remember it, and afterwards do the look-up of the group by
		it. But since on deletion the row with will come to the table's
		output label anyway, we can just ride the wave and remember it instead
		of doing the manual look-up. And this also spares the need of creating
		a row with the last symbol for searching: we get a ready pre-made row
		with the right symbol in it.
		</para>

		<para>
		Note that in this example, unlike the previous one, there are no two
		ways of finding the group any more: after deletion the row handle will
		not be in the table any more, and could not be used to jump directly to
		the beginning of its group. <pre>findIdx()</pre> has to be used to find the group.
		</para>

		<para>
		By the time <pre>printAverage()</pre> executes, it could happen that all the rows with that symbol
		will be gone, and the group will disappear. This situation is handled
		nicely in an automatic way: <pre>findIdx()</pre> will return a NULL row handle, for which then
		<pre>nextGroupIdx()</pre> will also return a NULL row handle. The for-loop will
		immediately satisfy the condition of <pre>$rhi->same($rhEnd)</pre>, it will
		make no iterations, the <pre>$count</pre> and <pre>$avg</pre> will be left undefined.
		In result no rows will be printed and the average value will be printed
		as <quote>Undefined</quote>, as you can see in the reaction to the last input row
		in the sample output.
		</para>

		<para>
		The main loop becomes reduced to reading the input, splitting the line,
		separating the opcode, calling the table's input label, and printing
		the average. The auto-conversion from the opcode name is used when
		constructing the rowop. Normally it's not a good practice, since the
		program will die if it finds a bad rowop in the input, but good enough
		for a small example. The direct use of <pre>$uTrades->call()</pre> 
		guarantees that by the time it returns, the last modified row
		will be remembered in <pre>$rLastMod</pre>, available for <pre>printAverage()</pre>
		to use.
		</para>

		<para>
		After the average is calculated, <pre>$rLastMod</pre> is reset to prevent it from
		accidentally affecting the next row. If the next row is an attempt to
		delete a trade id that is not in the table any more, the DELTE operation
		will have no effect on the table, and nothing will be sent from the
		table's output label. <pre>$rLastMod</pre> will stay undefined, and
		<pre>printAverage()</pre> will check it and immediately return.
		An attempt to pass an <pre>undef</pre> argument to <pre>findIdx()</pre> would be an error.
		</para>

		<para>
		The final <pre>$uTrades->drainFrame()</pre> is there purely for
		completeness. In this case we know that nothing will be scheduled by
		the labels downstream from the table, and there will be nothing to
		drain.
		</para>

		<indexterm>
			<primary>table</primary>
			<secondary>find</secondary>
		</indexterm>
		<indexterm>
			<primary>index</primary>
			<secondary>default</secondary>
		</indexterm>
		<indexterm>
			<primary>index</primary>
			<secondary>order</secondary>
		</indexterm>
		<indexterm>
			<primary>index</primary>
			<secondary>primary</secondary>
		</indexterm>
		<para>
		Now, an interesting question is: how does the table know, that to
		delete a row, it has to find it using the field <pre>id</pre>? Or, since
		the deletion internally uses <pre>find()</pre>, the more precise question is: how
		does <pre>find()</pre> know that it has to use the index <pre>byId</pre>? It doesn't
		use any magic. It simply goes by the first index defined in the table.
		That's why the index <pre>byId</pre> has been very carefully placed before
		<pre>bySymbol</pre>. The same principle applies to all the other functions
		like <pre>next()</pre>, that use an index but don't receive one as an argument:
		the first index is always the default index. There is a bit more detail to
		it, but that's the rough principle.
		</para>
	</sect1>

	<sect1 id="sc_table_sorted">
		<title>Sorted index</title>

		<para>
		The hashed index provides a way to store rows indexed by a key. It is fast
		but it has a price to pay for that speed: when iterating through it,
		the records come in an unpredictable (though repeatable, within a
		particular machine architecture) order determined by the hash function.
		If the order doesn't matter, that's fine. But often the order does
		matter, and is desirable even at the tradeoff of the reduced performance.
		</para>

		<indexterm>
			<primary>index</primary>
			<secondary>sorted</secondary>
		</indexterm>
		<para>
		The sorted index provides a solution for this problem. It is created
		with:
		</para>

<pre>
$it = Triceps::IndexType->newPerlSorted($sortName,
  \&initFunc, \&compareFunc, @args);
</pre>

		<para>
		The <quote>Perl</quote> in <quote>newPerlSorted</quote> refers to the
		fact that the sorting order is specified as a Perl comparison function.
		</para>

		<para>
		<pre>$sortName</pre> is just a symbolic name for printouts. It's used when you
		call <pre>$it->print()</pre> (directly or as a recursive call from the table
		type print) to let you know what kind of index type it is, since it
		can't print the compiled comparison function. It is also used in the
		error messages if something dies inside the comparison function: the
		comparison is executed from deep inside the &Cpp; code, and by that time
		the <pre>$sortName</pre> is the only way to identify the source of the problems.
		It's not the same name as used to connect the index type into the table
		type hierarchy with <pre>addSubIndex()</pre>. As usual, an index type may be
		reused in multiple hierarchies, with different names, but in all cases
		it will also keep the same <pre>$sortName</pre>. This may be easier to show with an
		example:
		</para>

<pre>
$rt1 = Triceps::RowType->new(
	a => "int32",
	b => "string",
) or confess "$!";

$it1 = Triceps::IndexType->newPerlSorted("basic", undef, \&compBasic)
	or confess "$!"; 

$tt1 = Triceps::TableType->new($rt1)
	->addSubIndex("primary", $it1)
	or confess "$!"; 

$tt2 = Triceps::TableType->new($rt1)
	->addSubIndex("first", $it1)
	or confess "$!";

print $tt1->print(), "\n";
print $tt2->print(), "\n";
</pre>

		<para>
		The print calls in it will produce:
		</para>

<pre>
table (
  row {
    int32 a,
    string b,
  }
) {
  index PerlSortedIndex(basic) primary,
}
table (
  row {
    int32 a,
    string b,
  }
) {
  index PerlSortedIndex(basic) first,
}
</pre>

		<para>
		Both the name of the index type in the table type and the name of
		the sorted index type are printed, but in different spots.
		</para>

		<para>
		The <pre>initFunc</pre> and/or <pre>compareFunc</pre> references specify the sorting order.
		One of them may be left undefined but not both. <pre>@args</pre> are the optional
		arguments that will be passed to both functions.
		</para>

		<para>
		The easiest but least flexible way is to just use the
		<pre>compareFunc</pre>. It gets two Rows (not RowHandles!) as arguments, plus
		whatever is specified in <pre>@args</pre>. It returns the usual Perl-style
		<quote>&lt;=&gt;</quote> result. For example:
		</para>

<pre>
sub compBasic # ($row1, $row2)
{
	return $_[0]->get("a") <=> $_[1]->get("a");
}
</pre>

		<para>
		Don't forget to use <quote>&lt;=&gt;</quote> for the numbers and <quote>cmp</quote> for the
		strings. The typical Perl idiom for sorting by more than one field is
		to connect them by <quote>||</quote>.
		</para>

		<para>
		Or, if we want to specify the field names as arguments, we could define
		a sort function that sorts first by a numeric field in ascending order,
		then by a string field in descending order:
		</para>

<pre>
sub compAscDesc # ($row1, $row2, $numFldAsc, $strFldDesc)
{
	my ($row1, $row2, $numf, $strf) = @_;
	return $row1->get($numf) <=> $row2->get($numf)
		|| $row2->get($strf) cmp $row1->get($strf); # backwards for descending
}

my $sit = Triceps::IndexType->newPerlSorted("by_a_b", undef,
	\&compAscDesc, "a", "b") or die "$!";
</pre>

		<para>
		This assumes that the row type will have a numeric field <quote>a</quote> and a
		string field <quote>b</quote>. The problem is that if it doesn't then this will not
		be discovered until you create a table and try to insert some rows into
		it, which will finally call the comparison function. Even then it won't
		be exactly obvious because this comparison function never checks <pre>"$!"</pre>
		after <pre>get()</pre>, and you'll see no failures but all the rows will be
		considered equal and will replace each other.
		</para>

		<para>
		You could check that the arguments match the row type
		(<pre>$row1->getType()</pre>) in the comparison function but that would add
		extra overhead, and the Perl comparisons are slow enough as they are.
		</para>

		<para>
		The <pre>initFunc</pre> provides a way to do that check and more.
		It is called at the table type initialization time. By this time all
		this extra information is known, and it gets the references to the
		table type, index type (itself, but with the class stripped back to
		Triceps::IndexType), row type, and whatever extra arguments that were
		passed. It can do all the checks once.
		</para>

		<para>
		The init function's return value is kind of backwards to everything
		else: on success it returns <pre>undef</pre>, on error it returns the error
		message. It could die too, but simply returning an error message is
		somewhat nicer. The returned error messages may contain multiple 
		lines separated by <quote>\n</quote>, so it should try to collect all the error
		information it can.
		</para>

		<para>
		The init function that would check the arguments for the
		last example can be defined as:
		</para>

<pre>
sub initNumStr # ($tabt, $idxt, $rowt, @args)
{
	my ($tabt, $idxt, $rowt, @args) = @_;
	my %def = $rowt->getdef(); # the field definition
	my $errors; # collect as many errors as possible
	my $t;

	if ($#args != 1) {
		$errors .= "Received " . ($#args + 1) . " arguments, must be 2.\n"
	} else {
		$t = $def{$args[0]};
		if ($t !~ /int32$|int64$|float64$/) {
			$errors .= "Field '" . $args[0] . "' is not of numeric type.\n"
		}
		$t = $def{$args[1]};
		if ($t !~ /string$|uint8/) {
			$errors .= "Field '" . $args[1] . "' is not of string type.\n"
		}
	}

	if (defined $errors) {
		# help with diagnostics, append the row type to the error listing
		$errors .= "the row type is:\n";
		$errors .= $rowt->print();
	}
	return $errors;
}

my $sit = Triceps::IndexType->newPerlSorted("by_a_b", \&initNumStr,
	\&compAscDesc, "a", "b") or die "$!";
</pre>

		<para>
		The init function can do even better: it can create and set
		the comparison function. It's done with:
		</para>

<pre>
$idxt->setComparator(\&compareFunc)
	or return "Failed to set comparator: $!";
</pre>

		<para>
		Instead of the usual <quote><pre>or confess</pre></quote>, 
		this snippet shows <quote><pre>or return</pre></quote>
		because this is the error indication convention of the init
		function. But <quote><pre>or confess</pre></quote> woudl work too.
		</para>

		<para>
		When the init function sets the comparator,
		the compare function argument in <pre>newPerlSorted()</pre>
		can be left undefined, because <pre>setComparator()</pre> would override
		it anyway. But one way or the other, the compare function
		must be set, or the index type initialization and with it
		the table type initialization will fail.
		</para>

		<indexterm>
			<primary>aggregation</primary>
		</indexterm>
		<para>
		By the way, the sorted index type init function is <b>not</b> of the
		same kind as the aggregator type init function. The aggregator type
		could use an init function of this kind too, but at the time it looked
		like too much extra complexity. It probably will be added in the
		future. But more about aggregators later.
		</para>

		<para>
		A fancier example of the init function will be shown in the next
		section.
		</para>

		<indexterm>
			<primary>index</primary>
			<secondary>hashed</secondary>
		</indexterm>
		<para>
		Internally the implementation of the sorted index shares much
		with the hashed index. They both are implemented as trees but they
		compare the rows in different ways. The hashed index is aimed
		for speed, the sorted index for flexibility. The common implementation
		means that they share certain traits. Both kinds have the unique keys,
		there can not be two rows with the same key in an index of either kind.
		Both kinds allow to nest other indexes in them.
		</para>
	</sect1>

	<sect1 id="sc_table_ordered">
		<title>Ordered index</title>

		<indexterm>
			<primary>index</primary>
			<secondary>ordered</secondary>
		</indexterm>
		<indexterm>
			<primary>template</primary>
		</indexterm>
		<indexterm>
			<primary>code generation</primary>
		</indexterm>
		<para>
		To specify the sorting order in a more SQL-like fashion, Triceps
		has the class SimpleOrderedIndex. It's implemented entirely in Perl, on
		top of the sorted index. Besides being useful by itself, it shows off
		two concepts: the initialization function of the sorted index, and the
		template with code generation on the fly.
		</para>

		<para>
		First, how to create an ordered index:
		</para>

<pre>
$it = Triceps::SimpleOrderedIndex->new($fieldName => $order, ...)
	or confess "$!";
</pre>

		<para>
		The arguments are the key fields. <pre>$order</pre> is one of
		<pre>"ASC"</pre> for ascending and <pre>"DESC"</pre> for descending.
		Here is an example of a table with this index:
		</para>

<pre>
my $tabType = Triceps::TableType->new($rowType)
	->addSubIndex("sorted", 
		Triceps::SimpleOrderedIndex->new(
			a => "ASC",
			b => "DESC",
		)
	) or confess "$!";
</pre>

		<para>
		When it gets translated into a sorted index, the comparison function
		gets generated automatically. It's smart enough to generate the string
		comparisons for the <pre>string</pre> and <pre>uint8</pre> fields, and the numeric
		comparisons for the numeric fields. It's not smart enough to do the
		locale-specific comparisons for the strings and locale-agnostic for the
		<pre>uint8</pre>, it just uses whatever you have set up in <pre>cmp</pre> for both. It
		treats the NULL field values as numeric 0 or empty strings. It doesn't
		handle the array fields at all but can at least detect such attempts
		and flag them as errors.
		</para>

		<para>
		A weird artifact of the boundary between &Cpp; and Perl is that when you
		get the index type back from the table type like
		</para>

<pre>
$sortIdx = $tabType->findSubIndex("sorted") or confess "$!";
</pre>

		<para>
		the reference stored in <pre>$sortIdx</pre> will be of the base type
		Triceps::IndexType. That's because the &Cpp; internals of the TableType
		object know nothing about any derived Perl types. But it's no big deal,
		since there are no other useful methods for SimpleOrderedIndex anyway.
		For the future, I have an idea of a workaround, but it has to wait
		for the future.
		</para>

		<para>
		If you call <pre>$sortIdx->print()</pre>, it will give you an idea of how it
		was constructed:
		</para>

<pre>
PerlSortedIndex(SimpleOrder a ASC, b DESC, )
</pre>

		<para>
		The contents of the parenthesis is a sort name from the sorted index'es
		standpoint. It's an arbitrary string. But when the ordered index
		prepares this string to pass to the sorted index, it puts its
		arguments into it.
		</para>

		<para>
		Now the interesting part, I want to show the implementation of the
		ordered index. It's not too big and it shows the flexibility and the
		extensibility of Triceps:
		</para>

<!-- lib/Triceps/SimpleOrderedIndex.pm with XXX lines dropped  -->
<pre>
package Triceps::SimpleOrderedIndex;
use Carp;

our @ISA = qw(Triceps::IndexType);

# Create a new ordered index. The order is specified
# as pairs of (fieldName, direction) where direction is a string
# "ASC" or "DESC".
sub new # ($class, $fieldName => $direction...)
{
	my $class = shift;
	my @args = @_; # save a copy

	# build a descriptive sortName
	my $sortName = 'SimpleOrder ';
	while ($#_ >= 0) {
		my $fld = shift;
		my $dir = shift;
		$sortName .= quotemeta($fld) . ' ' . quotemeta($dir) . ', ';
	}

	$self = Triceps::IndexType->newPerlSorted(
		$sortName, \&init, undef, @args
	) or confess "$!";
	bless $self, $class;
	return $self;
}

# The initialization function that actually parses the args.
sub init # ($tabt, $idxt, $rowt, @args)
{
	my ($tabt, $idxt, $rowt, @args) = @_;
	my %def = $rowt->getdef(); # the field definition
	my $errors; # collect as many errors as possible
	my $compare = "sub {\n"; # the generated comparison function
	my $connector = "return"; # what goes between the comparison operators

	while ($#args >= 0) {
		my $f = shift @args;
		my $dir = uc(shift @args);

		my ($left, $right); # order the operands depending on sorting direction
		if ($dir eq "ASC") {
			$left = 0; $right = 1;
		} elsif ($dir eq "DESC") {
			$left = 1; $right = 0;
		} else {
			$errors .= "unknown direction '$dir' for field '$f', use 'ASC' or 'DESC'\n";
			# keep going, may find more errors
		}
	
		my $type = $def{$f};
		if (!defined $type) {
			$errors .= "no field '$f' in the row type\n";
			next;
		}

		my $cmp = "<=>"; # the comparison operator
		if ($type eq "string"
		|| $type =~ /^uint8.*/) {
			$cmp = "cmp"; # string version
		} elsif($type =~ /\]$/) {
			$errors .= "can not order by the field '$f', it has an array type '$type', not supported yet\n";
			next;
		}

		my $getter = "->get(\"" . quotemeta($f) . "\")";

		$compare .= "  $connector \$_[$left]$getter $cmp \$_[$right]$getter\n";

		$connector = "||";
	}

	$compare .= "  ;\n";
	$compare .= "}";

	if (defined $errors) {
		# help with diagnostics, append the row type to the error listing
		$errors .= "the row type is:\n";
		$errors .= $rowt->print();
	} else {
		# compile the comparison
		#print STDERR "DEBUG Triceps::SimpleOrderedIndex::init: comparison function:\n$compare\n";
		my $cmpfunc = eval $compare 
			or return "Triceps::SimpleOrderedIndex::init: internal error when compiling the compare function:\n"
				. "$@\n"
				. "The generated comparator was:\n"
				. $compare;
		$idxt->setComparator($cmpfunc)
			or return "Triceps::SimpleOrderedIndex::init: internal error: can not set the compare function:\n"
			. "$!\n";
	}
	return $errors;
}
</pre>

		<para>
		The class constructor simply builds the sort name from the arguments
		and offloads the rest of logic to the init function. It can't really do
		much more: when the index type object is constructed, it doesn't know
		yet, where it will be used and what row type it will get. It tries to
		enquote nicely the weird characters in the arguments when they go into
		the sort name. Not that much use is coming from it at the moment: the
		&Cpp; code that prints the table type information doesn't do the same, so
		there still is a chance of misbalanced quotes in the result. But
		perhaps the &Cpp; code will be fixed at some point too.
		</para>

		<para>
		The init function is called at the table type initialization time
		with all the needed information.
		It goes through all the arguments, looks up the fields in the row type,
		and checks them for correctness. It tries to collect as much of the
		error information as possible. The returned error messages may contain
		multiple lines separated by <quote>\n</quote>, and the ordered index makes use of
		it. The error messages get propagated back to the table type level,
		nicely indented and returned from the table initialization. If the init
		function finds any errors, it appends the printout of the row type too,
		to make finding what went wrong easier. A result of a particularly bad
		call to a table type initialization may look like this:
		</para>

<!-- t/SimpleOrderedIndex.t errors -->
<pre>
index error:
  nested index 1 'sorted':
    unknown direction 'XASC' for field 'z', use 'ASC' or 'DESC'
    no field 'z' in the row type
    can not order by the field 'd', it has an array type 'float64[]', not supported yet
    the row type is:
    row {
      uint8 a,
      uint8[] b,
      int64 c,
      float64[] d,
      string e,
    }
</pre>

		<para>
		Also as the init goes through the arguments, it constructs the text of
		the compare function in the variable <pre>$compare</pre>. Here the use of
		<pre>quotemeta()</pre> for the user-supplied strings is important to avoid the
		syntax errors in the generated code. If no errors are found in the
		arguments, the compare function gets compiled with <pre>eval</pre>. There
		should not be any errors, but it's always better to check. Finally the
		compiled compare function is set in the sorted index with
		</para>

<pre>
$idxt->setComparator($cmpfunc)
</pre>

		<para>
		If you uncomment the debugging printout line (and run <quote><pre>make</pre></quote>, and maybe
		<quote><pre>make install</pre></quote> afterwards), you can see the auto-generated code printed
		on stderr when you use the simple ordered index. It will look somewhat
		like this:
		</para>

<pre>
sub {
	return $_[0]-&gt;get("a") cmp $_[1]-&gt;get("a")
	|| $_[1]-&gt;get("c") &lt;=&gt; $_[0]-&gt;get("c")
	|| $_[0]-&gt;get("b") cmp $_[1]-&gt;get("b")
	;
}
</pre>

		<para>
		That's it! An entirely new piece of functionality added in a smallish Perl
		snippet. This is your typical Triceps template: collect the arguments,
		use them to build Perl code, and compile it. Of course, if you don't
		want to deal with the code generation and compilation, you can just
		call your class methods and whatnot to interpret the arguments. But if
		the code will be reused, the compilation is more efficient.
		</para>

		<para>
		</para>

		<para>
		</para>
	</sect1>

</chapter>
