<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5CR3//EN"
	"http://www.oasis-open.org/docbook/xml/4.5CR3/docbookx.dtd" [
<!ENTITY % userents SYSTEM "file:///ENTS/user.ent" >
%userents;
]>

<!--
(C) Copyright 2011-2012 Sergey A. Babkin.
This file is a part of Triceps.
See the file COPYRIGHT for the copyright notice and license information
-->


<chapter id="ch_api_fund" xmlns:xi="http://www.w3.org/2001/XInclude">
	<title>API Fundamentals</title>

	<sect1 id="sc_api_lang">
		<title>Languages and layers</title>

		<para>
		As mentioned before, at the moment Triceps provides the APIs in &Cpp; and
		Perl. They are similar but not quite the same, because the nature of
		the compiled and scripted languages is different. The &Cpp; API is more
		direct and expects discipline from the programmer: if some incorrect
		arguments are passed, everything might crash. The Perl API should never
		crash. It should detect any incorrect use and report an orderly error.
		Besides, the idioms of the scripted languages are different from the
		compiled languages, and different usages become convenient.
		</para>

		<indexterm>
			<primary>C++</primary>
		</indexterm>
		<para>
		So far only the Perl API is documented in this manual. Its is considered
		the primary one for the end users, and also richer and easier to use.
		The &Cpp; API will be documented as well, just it didn't make the cut for
		the version 1.0. If you're interested in the &Cpp; API, read the Perl
		documentation first, to understand the ideas of Triceps, and then
		look in the source code. The &Cpp; classes have very extensive comments
		in the header files.
		</para>

		<indexterm>
			<primary>XS</primary>
		</indexterm>
		<indexterm>
			<primary>SWIG</primary>
		</indexterm>
		<para>
		The Perl API is implemented in XS. Some people, may wonder, why not
		SWIG? SWIG would automatically export the API into many languages, not
		just Perl. The problem with SWIG is that it just maps the API
		one-to-one. And this doesn't work any good, it makes for some very ugly
		APIs with abilities to crash from the user code. Which then have to be
		wrapped into more scripting code before they become usable. So then why
		bother with SWIG, it's easier to just use the scripting language's
		native extension methods.  Another benefit of the native XS support is
		the access to the correct memory management.
		</para>

		<para>
		In general, I've tried to avoid the premature optimization. The idea is
		to get it working at all first, and then bother about working fast.
		Except for the cases when the need for optimization looked obvious, and
		the logic intertwined with the general design strongly ehough, that if
		done one way, would be difficult to change in the future. We'll see, if
		these <quote>obvious</quote> cases really turn out to be the obvious
		wins, or will they become a premature-optimization mess.
		</para>

		<para>
		There is usually more than one way to do something in Triceps. It has 
		been written in layers: There is the &Cpp; API layer on the bottom, then
		the Perl layer that closely parallels it, then more of the niceties
		built in Perl. There is more than one way to organize the manual,
		structuring it by features or by layers. Eventually I went in the
		order of the major features, discussing each one of them at various
		layers. 
		</para>

		<para>
		I've also tried to show, how these layers are built on top of each other
		and connected. Which might be too much detail for the first reading.
		If you feel that something is going over your head, just skim over it.
		It could be marked more clearly but I don't like this kind of marking.
		I hate the side-panels in the magazines. I like the text to flow smoothly
		and sequentially. I don't like the <quote>simplifications</quote> that
		distort the real meaning and add all kinds of confusion. I like
		having all the details I can get, and then I can skip over the ones
		that look too complicated (and read them again when they start making
		sense).
		</para>

		<para>
		Also, a major goal of Triceps is the extendability.  And the best way
		to learn how to extend it, is by looking up close at how it has already
		been extended.
		</para>
	</sect1>

	<sect1 id="sc_memory">
		<title>Memory management</title>

		<indexterm>
			<primary>memory management</primary>
		</indexterm>
		<para>
		The memory is managed in Triceps using the reference counters. Each
		Triceps object has a reference counter in it. In &Cpp; this is done
		explicitly, in Perl it gets mostly hidden behind the Perl memory
		management that also uses the reference counters. Mostly.
		</para>

		<indexterm>
			<primary>Autoref</primary>
		</indexterm>
		<para>
		In &Cpp; the Autoref template is used to produce the reference objects.
		As the references are copied around between these objects, the
		reference counts in the target objects are automatically adjusted. When
		the reference count drops to 0, the target object gets destroyed. While
		there are live references, the object can't get destroyed from under
		them. All nice and well and simple, however still possible to get
		wrong.
		</para>

		<indexterm>
			<primary>label</primary>
		</indexterm>
		<para>
		The major problem with the reference counters is the reference loops.
		If object A has a reference to object B, and object B has a reference
		(possibly, indirect) to object A, then neither of them will ever be
		destroyed. Many of these cases can be resolved by keeping a reference
		in one direction and a plain pointer in the other. This of course
		introduces the problem of hanging pointers, so extra care has to be
		taken to not reference them. There also are the unpleasant situations
		when there is absolutely no way around the reference loops. For
		example, the Triceps label's method may keep a reference to the next
		label, where to send its processed results. If the labels are connected
		into a loop (a perfectly normal occurrence), this would cause a
		reference loop. Here the way around is to know when all the labels are
		no longer used (before the thread exit), and explicitly tell them to
		clear their references to the other labels. This breaks up the loop,
		and then bits and pieces can be collected by the reference count logic.
		</para>

		<para>
		The reference loop problem can be seen all the way up into the Perl level.
		However Triceps provides the ready solutions for its typical occurences.
		</para>

		<para>
		The reference counting may be single-threaded or multi-threaded. If an
		object may only be used inside one thread, the references to it use the
		faster single-threaded counting. In &Cpp; it's real important to not
		access and not reference the single-threaded objects from multiple
		threads. In Perl, when a new thread is created, only the multithreaded
		objects from the parent thread become accessible for it, the rest become
		undefined, so the issue gets handled automatically (as of version 1.0
		even the potentially multithreaded objects are still exported to Perl
		as single-threaded, with no connection between threads yet).
		</para>

		<indexterm>
			<primary>wrapper</primary>
		</indexterm>
		<para>
		The &Cpp; objects are exported into Perl through wrappers. The wrappers
		perform the adaptation between Perl reference counting and Triceps
		reference counting, and sometimes more of the helper functions. Perl
		sees them as blessed objects, from which you can inherit and otherwise
		treat like normal objects. 
		</para>

		<para>
		When we say that a Perl variable <pre>$label</pre> contains a Triceps
		label object, it really means that it contains a <i>referece</i> to
		a label object. When it gets copied like <pre>$label2 = $label</pre>,
		this copies the reference and now both variables refer to the same
		label object (more exactly, even to the same wrapper object). Any 
		changes to the object's state done through one
		reference will also be visible through the other reference.
		</para>

		<para>
		When the Perl references are copied between the variables, this
		increases the Perl reference count to the same wrapper object. However
		if an object goes into the &Cpp; land, and then is extracted back (such
		as, create a Rowop from a Row, and then extract the Row from that
		Rowop), a brand new wrapper gets created. It's the same underlying &Cpp;
		object but with multiple wrappers. You can't tell that it's the same
		object by comparing the Perl references, because they may be pointing
		to the different wrappers. However Triceps provides the method
		<pre>same()</pre> that compares the data inside the wrappers. It can be
		used as
		</para>

<pre>
$row1->same($row2)
</pre>

		<para>
		and if it returns true, then both <pre>$row1</pre> and <pre>$row2</pre> point to the same
		underlying row. 
		</para>

		<para>
		Note also that if you inherit from the Triceps objects
		and add some extra data to them, none of that data nor even your
		derived class'es identity will be preserved when a new wrapper is created
		from the underlying &Cpp; object.
		</para>
	</sect1>

	<sect1 id="sc_constants">
		<title>Triceps constants</title>

		<indexterm>
			<primary>constants</primary>
		</indexterm>
		<para>
		Triceps has a number of symbolic constants that are grouped into
		essentially enums. The constants themselves will be introduced with the
		classes that use them, but here is the general description common to
		them all.
		</para>

		<para>
		In Perl they all are placed into the same namespace. Each group of
		constants (that can be thought of as an enum) gets its name prefix. For
		example, the operation codes are all prefixed with OP_, the enqueueing
		modes with EM_, and so on.
		</para>

		<para>
		The underlying constants are all integer. The way to give symbolic
		names to constants in Perl is to define a function without arguments
		that would return the value. Each constant has such a function defined
		for it. For example, the opcode for the <quote>insert</quote> operation is the
		result of function <pre>Triceps::OP_INSERT</pre>. 
		</para>

		<para>
		Most methods that take constants as arguments are also smart enough to
		recognise the constant names as strings, and automatically convert them
		to integers. For example, the following calls are equivalent:
		</para>

<pre>
$label->makeRowop(&Triceps::OP_INSERT, ...);
$label->makeRowop("OP_INSERT", ...);
</pre>

		<para>
		For a while I've thought that the version with
		<pre>Triceps::OP_INSERT</pre> would be more efficient and might check
		for correctness of the name at compile time.  But as it turns out, no,
		on both counts. The look-up of the function by name happens at run
		time, so there is no compile-time check.  And that look-up happens to
		be a little slower than the one done by the Triceps &Cpp; code, so
		there is no win there either. The string version is not only shorter
		but also more efficient. The only win with the function is if you call it
		once, remember the result in a variable and then reuse. Unless you're 
		chasing the last few percent of performance in a tight loop, it's not
		worth the trouble. Perhaps in the future the functions will be replaced
		with the module-level variables: <i>that</i> would be both faster and
		allow the compile-time checking with <pre>use strict</pre>.
		</para>

		<para>
		What if you need to print out a constant in a message? Triceps provides
		the conversion functions for each group of constants. They generally
		are named <computeroutput>Triceps::<i>something</i>String</computeroutput>. 
		For example,
		</para>

<pre>
print &Triceps::opcodeString(&Triceps::OP_INSERT);
</pre>

		<indexterm>
			<primary>error handling</primary>
		</indexterm>
		<para>
		would print <quote>OP_INSERT</quote> If the argument is out of range of
		the valid enums, it would return <pre>undef</pre> (but not set any error
		message in <pre>$!</pre>, since it's not a fatal error).
		</para>

		<para>
		There also are functions to convert from strings to constant values.
		They generally are named <computeroutput>Triceps::string<i>Something</i></computeroutput>. 
		For example,
		</para>

<pre>
&Triceps::stringOpcode("OP_INSERT")
</pre>

		<para>
		would return the integer value of <pre>Triceps::OP_INSERT</pre>. If the
		string name is not valid for this kind of constants, it would also
		return <pre>undef</pre>.
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>
	</sect1>

</chapter>
