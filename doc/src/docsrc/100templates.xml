<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5CR3//EN"
	"http://www.oasis-open.org/docbook/xml/4.5CR3/docbookx.dtd" [
<!ENTITY % userents SYSTEM "file:///ENTS/user.ent" >
%userents;
]>

<!--
(C) Copyright 2011-2012 Sergey A. Babkin.
This file is a part of Triceps.
See the file COPYRIGHT for the copyright notice and license information
-->

<chapter id="ch_templates" xmlns:xi="http://www.w3.org/2001/XInclude">
	<title>Templates</title>

	<sect1 id="sc_template_intro">
		<title>Comparative modularity</title>

		<indexterm>
			<primary>template</primary>
		</indexterm>
		<para>
		The templates are the Triceps term for the reusable program modules.
		I've adopted the term from &Cpp; because that was my inspiration
		for flexibility. But the Triceps templates are much more flexible yet.
		The problem with the &Cpp; templates is that you have to write in them
		like in a functional language, substituting loops with recursion,
		with perverse nested calls for branching, and the result is quite
		hard to diagnose. Triceps uses the Perl's compilation on the fly
		to make things easier and more powerful.
		</para>

		<para>
		Triceps is not unique in the desire for modularity. The other CEP
		systems have it too, but they tend to have it even more rigid than
		the &Cpp; templates.  Let me show on a simple example.
		</para>

		<indexterm>
			<primary>Coral8</primary>
		</indexterm>
		<para>
		Coral8 doesn't provide a way to query the windows directly, especially
		when the CCL is compiled without debugging. So you're expected to make
		your own. People at a company where I've worked have developed a nice
		pattern that goes approximately like this:
		</para>

		<indexterm>
			<primary>CCL</primary>
		</indexterm>
<pre>
// some window that we want to make queryable
create window w_my schema s_my
keep last per key_a per key_b
keep 1 week;

// the stream to send the query requests
// (the schema can be shared by all simple queries) 
create schema s_query (
	qqq_id string // unique id of the query
);
create input stream query_my schema s_query;

// the stream to return the results
// (all result streams will inherit a partial schema)
create schema s_result (
	qqq_id string, // returns back the id received in the query
	qqq_end boolean, // will be TRUE in the special end indicator record
);
create output stream result_my schema inherits from s_result, s_my;

// now process the query
insert into result_my
select q.qqq_id, NULL, w.*
from s_query as q, w_my as w;

// the end marker
insert into result_my (qqq_id, qqq_end)
select qqq_id, TRUE
from s_query;
</pre>

		<para>
		To query the window, a program would select a unique query id,
		subscribe to result_my with a filter <pre>(qqq_id = unique_id)</pre> and send a
		record of <pre>(unique_id)</pre> into <pre>query_my</pre>. Then it would sit and
		collect the result rows. Finally it would get a row with <pre>qqq_end = TRUE</pre>
		and disconnect.
		</para>

		<para>
		This is a fairly large amount of code to be repeated for every window.
		What I would like to to instead is to just write:
		</para>

<pre>
create window w_my schema s_my
keep last per key_a per key_b
keep 1 week;

make_queryable(w_my);
</pre>

		<para>
		and have the template <pre>make_queryable</pre> expand into the rest of the code
		(obviously, the schema definitions would not need to be expanded
		repeatedly, they would go into an include file).
		</para>

		<para>
		To make things more interesting, it would be nice to have the query
		filter the results by some field values. Nothing as fancy as SQL, just
		by equality to some fields. Suppose, s_my includes the fields field_c
		and field_d, and we want to be able to filter by them. Then the query
		can be done as:
		</para>

<pre>
create input stream query_my schema inherits from s_query (
	field_c integer,
	field_d string
);

// result_my is the same as before...

// query with filtering (in a rather inefficient way) 
insert into result_my
select q.qqq_id, NULL, w.*
from s_query as q, w_my as w
where
	(q.field_c is null or q.field_c = w.field_c)
	and (q.field_d is null or q.field_d = w.field_d);

// the end marker is as before
insert into result_my (qqq_id, qqq_end)
select qqq_id, TRUE
from s_query;
</pre>

		<para>
		It would be nice then to create this kind of query as a template
		instantiation
		</para>

<pre>
make_query(w_my, (field_c, field_d));
</pre>

		<para>
		Or even better, have the template determine the non-NULL
		fields in the query record and compile the right query on the
		fly.
		</para>

		<indexterm>
			<primary>Sybase</primary>
		</indexterm>
		<indexterm>
			<primary>StreamBase</primary>
		</indexterm>
		<para>
		But the Coral8 modules (nor the later Sybase CEP R5) aren't flexible
		enough to do any of it. A CCL module requires a fixed schema for all its
		interfaces.
		The StreamBase language is more flexible and
		allows to achieve some of the flexibility through the capture
		fields, where the <quote>logically unimportant</quote> fields
		are carried through the module as one combined payload field. 
		But they don't allow the variable lists of fields as parameters either,
		nor generation of different model topologies depending on the parameters.
		</para>
	</sect1>

	<sect1 id="sc_template_variety">
		<title>Template variety</title>

		<para>
		A template in Triceps is generally a function or class that
		creates a fragment of the model based on its arguments.
		It provides the access points used to connect this fragment to the rest
		of the model.
		</para>

		<para>
		There are different ways do do this. They can be broadly classified 
		in the order of increasing complexity as:
		</para>

		<itemizedlist>
		<listitem>
		A function that creates a single Triceps object and returns it.
		The benefit is that the function would automatically choose some complex
		object parameters based on the function parameters, thus turning
		a complex creation into a simple one.
		</listitem>
		<listitem>
		A class that similarly creates multiple fixed objects and interconnects
		them properly. It would also provide the accessor methods to export
		the access points of this sub-model. Since the Perl functions may
		return multiple values, this functionality sometimes can be
		conveniently done with a function as well, returning the access
		points in the return array.
		</listitem>
		<listitem>
		A class or function that creates multiple objects, with their number and
		connections dependent on the parameters. For a simple example, a template
		might receive multiple functions/closures as arguments and then create
		a pipeline of computational labels, each of them computing one
		function (of course, this really makes sense only when each label
		runs in a separate thread).
		</listitem>
		<listitem>
		A class or function that automatically generates the Perl code that
		will be used in the created objects. For a simple example, given the
		pairs of field names and values, a template can generate the code for a filter
		label that would pass only the rows where these fields have these values.
		The same effect can often be achieved by the interpretation as well:
		keep the arguments until the evaluation needs to be done, and then
		interpret them. But the early code generation with compilation 
		improves the efficiency of the computation. It's the same idea
		as in the &Cpp; templates: do more of the hard work at the compile time
		and then run faster.
		</listitem>
		</itemizedlist>

		<para>
		The more complex and flexible is the template, the more difficult
		it's generally to write and debug, but then it just works, encapsulating
		a complex problem with a simpler interface. There is also the problem
		of user errors: when the user gives an incorrect argument to a complex
		template, understanding what exactly went wrong when the error manifests
		itself, may be quite difficult. The &Cpp; templates are a good
		example of this. However the use of Perl, a general programming
		language, as a template language in Triceps provides a good solution
		for this problem: just check the arguments early in the template and
		produce the meaningful error messages. It may be a bit cumbersome
		to write but then easy to use. I also have plans for improving the
		automatic error reports, to make tracking through the layers
		of templates easier with minimal code additions in the templates.
		</para>

		<para>
		I will show the examples of all the template types by implementing the table
		querying, the same I have shown in CCL in
		<xref linkend="sc_template_intro" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;,
		only now in Triceps.
		</para>
	</sect1>

	<sect1 id="sc_template_wrapper">
		<title>Simple wrapper templates</title>

		<para>
		The query examples will be using the main loop with sockets from the
		<xref linkend="sc_sched_mainloop_socket" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;.
		It has two repeating tasks: requesting the socket server to exit, and sending the
		rows from some label back into the socket. These tasks can be nicely handled
		with the simple templates:
		</para>

<pre>
package ServerHelpers;
use Carp;

# Exiting the server.
sub makeExitLabel # ($unit, $name)
{
	my $unit = shift;
	my $name = shift;
	return $unit->makeLabel($unit->getEmptyRowType(), $name, undef, sub {
		$srv_exit = 1;
	});
}

# Sending of rows to the server output.
sub makeServerOutLabel # ($fromLabel)
{
	my $fromLabel = shift;
	my $unit = $fromLabel->getUnit();
	my $fromName = $fromLabel->getName();
	my $lbOut = $unit->makeLabel($fromLabel->getType(), 
		$fromName . ".serverOut", undef, sub {
			&main::outCurBuf(join(",", $fromName, 
				&Triceps::opcodeString($_[1]->getOpcode()),
				$_[1]->getRow()->toArray()) . "\n");
		});
	$fromLabel->chain($lbOut) or confess "$!";
	return $lbOut;
}
</pre>

		<para>
		Each function is a separate template, they're wrapped into a common
		package only for the packaging reasons.
		</para>

		<para>
		<pre>makeExitLabel()</pre> is quite simple, it creates a label with hardcoded
		function of setting the variable <pre>$srv_exit</pre>. Even its row type
		is hardcoded to the empty rows.
		</para>

		<para>
		<pre>makeServerOutLabel()</pre> is more interesting. It prints the rows received from
		another label into the socket in the simple CSV (as usual, no commas in the
		values) format, the same as is expected by the socket server. It finds the
		unit and row type from that parent label, creates the printing label
		and chains it off the parent label. The newly created label is returned.
		The return value can be kept in a variable or immediately discarded;
		since the created label is already chained, it won't disappear.
		Tha name of the new label is produced from the name of the parent
		label by appending <quote>.serverOut</quote> to it.
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

	</sect1>

</chapter>
