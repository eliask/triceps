<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5CR3//EN"
	"http://www.oasis-open.org/docbook/xml/4.5CR3/docbookx.dtd" [
<!ENTITY % userents SYSTEM "file:///ENTS/user.ent" >
%userents;
]>

<!--
(C) Copyright 2011-2013 Sergey A. Babkin.
This file is a part of Triceps.
See the file COPYRIGHT for the copyright notice and license information
-->

	<sect1 id="sc_ref_fnreturn">
		<title>FnReturn reference</title>

		<indexterm>
			<primary>FnReturn</primary>
		</indexterm>
		<para>
		The FnReturn represents the return value of a streaming function.
		The return value consists of a stream of rowops, and gets processed
		by sending them to the labels through a binding.
		</para>

<pre>
$fret = Triceps::FnReturn->new($optName => $optValue, ...);
</pre>

		<para>
		Construct an FnReturn object. The options are:
		</para>

		<variablelist>
		<varlistentry>
			<term><pre>name</pre></term>
			<listitem>
			Name of this object. Will be used to create the names of the labels in it.
			</listitem>
		</varlistentry>

		<varlistentry>
			<term><pre>unit</pre></term>
			<listitem>
			The unit where this object belongs.
			</listitem>
		</varlistentry>

		<varlistentry>
			<term><pre>labels</pre></term>
			<listitem>
			<para>
			Definition of the labels in the FnReturn, where the results of the
			streaming function will be sent.
			The full names of these labels will be
			<quote>return_name.label_name</quote>. The label names within a 
			return must be unique.
			The value for this option is an array
			reference, with the labels defined as name-value pairs in the array, in
			one of two forms:
			</para>

<pre>
labels => [
	$name1 => $rowType1,
	$name2 => $fromLabel2,
	...
]
</pre>

			<para>
			If the second element in the pair is a row type, a label of that row type
			will be created in the FnReturn.
			</para>

			<para>
			If the second element in the pair is a label, its row type will be used
			to create a label in FnReturn and that new label will also be automatically
			chained off the specified one. This is convenient if you already have
			the logic of the function defined and just want to forward the result
			data from an existing label into the FnReturn.
			</para>
			</listitem>
		</varlistentry>

		<varlistentry>
			<term><pre>onPush</pre></term>
			<listitem>
			The code to execute whenever an FnBinding is pushed onto this FnReturn.
			This is useful to maintain the extended call contexts for the streaming
			function.
			Its argument can be specified in one of two forms: either just a code
			reference, or a reference to an array containing the code reference and
			the extra arguments for it. I.e. either <pre>onPush => $code</pre> or
			<pre>onPush => [ $code, @args ]</pre>. The first argument of the function
			will always be the FnReturn object itself, with extra arguments going
			after it: <pre>&$code($thisFnReturn, @optional_args)</pre>.
			</listitem>
		</varlistentry>

		<varlistentry>
			<term><pre>onPop</pre></term>
			<listitem>
			The code to execute whenever an FnBinding is popped from this FnReturn.
			This is useful to maintain the extended call contexts for the streaming
			function.
			Its argument can be specified in one of two forms: either just a code
			reference, or a reference to an array containing the code reference and
			the extra arguments for it. I.e. either <pre>onPop => $code</pre> or
			<pre>onPop => [ $code, @args ]</pre>. The first argument of the function
			will always be the FnReturn object itself, with extra arguments going
			after it: <pre>&$code($thisFnReturn, @optional_args)</pre>.
			</listitem>
		</varlistentry>
		</variablelist>

		<para>
		The FnReturn has a concept of clearing: and once any of the labels owned
		by the FnReturn gets cleared, the FnReturn is also cleared. The
		clearing drops the onPush and onPop handlers, thus breaking any
		reference cycles they might be engaged in.
		</para>

		<para>
		Also, when an FnReturn gets destroyed, it clears and disconnects from 
		the Unit all the labels defined in that FnReturn. This allows to create and destory
		the FnReturns dynamically if needed. Of course, if you do that, you should take
		care to discard the other references to its labels you might have.
		</para>

<pre>
$name = $fret->getName();
</pre>

		<para>
		Get back the object's name.
		</para>

<pre>
$res = $fret->size();
</pre>

		<para>
		Get the number of labels in the return.
		</para>

<pre>
@names = $fret->getLabelNames();
</pre>

		<para>
		Get an array of label names, in the same order as they were defined
		(the order of the label definitions is important).
		</para>

<pre>
@labels = $fret->getLabels();
</pre>

		<para>
		Get an array of references to the FnReturn's internal labels, in the
		same order as they were defined.
		</para>

<pre>
%labels = $fret->getLabelHash();
</pre>

		<para>
		Get the interspersed list of label names and references, suitable
		to initialize a hash.
		</para>

<pre>
%namemap = $fret->getLabelMapping();
</pre>

		<para>
		Get the interspersed list of label names and their indexes in order
		starting from 0, suitable to initialize a hash.
		</para>

<pre>
$label = $fret->getLabel($name);
</pre>

		<para>
		Get a label by name. Will confess if this name was not defined.
		</para>

<pre>
$label = $fret->getLabelAt($idx);
</pre>

		<para>
		Get a label by index, starting from 0. Will confess if the index is out of range.
		</para>

<pre>
$idx = $fret->findLabel($name);
</pre>

		<para>
		Translate a label name to index. Will confess if this name was not defined.
		</para>

<pre>
%rts = $fret->getRowTypeHash();
</pre>

		<para>
		Get the interspersed list of label names and references to their row types, suitable
		to initialize a hash. In Perl, this is the closest thing to the &Cpp; API's
		RowSetType.
		</para>

<pre>
$res = $fret->equals($fret2);
$res = $fret->equals($fbind2);
$res = $fret->match($fret2);
$res = $fret->match($fbind2);
</pre>

		<para>
		Convenience wrappers that compare the equality or match of types with
		an FnReturn or FnBinding.
		The types are considered equal if they contain the equal row
		types with equal names going in the same order. They are considered
		matching if they contain matching row types going in the same order,
		with any names. If the match condition seems surprising to you, think
		of it as <quote>nothing will break if one type is substituted for another at
		execution time</quote>.
		</para>

<pre>
$fret->push($fbind);
</pre>

		<para>
		Push a binding on the return stack. The binding must be of a matching type.
		The reference to the binding will be kept in the FnReturn until it's popped.
		</para>

<pre>
$fret->pop($fbind);
$fret->pop();
</pre>

		<para>
		Pop a binding from the return stack. The binding argument specifies,
		which binding is expected to be popped. Without argument, pops any
		binding. The call with argument is recommended since it
		allows to catch any mess-ups with the return stack early. If the stack
		is empty or the top binding is not the same as the argument, will confess.
		</para>

<pre>
$res = $fret->bindingStackSize();
</pre>

		<para>
		Get the current size of the return stack (AKA the stack of bindings). Useful
		for debugging.
		</para>

<pre>
@names = $fret->bindingStackNames();
</pre>

		<para>
		Get the names of all the bindings on the return stack. Useful for debugging.
		The top of stack is on the right.
		</para>

<pre>
$res = fret->isFaceted();
</pre>

		<indexterm>
			<primary>Facet</primary>
		</indexterm>
		<para>
		Returns 1 if this FnReturn object is a part of a Facet.
		</para>
	</sect1>
