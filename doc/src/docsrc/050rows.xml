<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5CR3//EN"
	"http://www.oasis-open.org/docbook/xml/4.5CR3/docbookx.dtd" [
<!ENTITY % userents SYSTEM "file:///ENTS/user.ent" >
%userents;
]>

<!--
(C) Copyright 2011-2012 Sergey A. Babkin.
This file is a part of Triceps.
See the file COPYRIGHT for the copyright notice and license information
-->


<chapter id="ch_Rows" xmlns:xi="http://www.w3.org/2001/XInclude">
	<title>Rows</title>

	<para>
	In Triceps the relational data is stored and passed around as rows
	(once in a while I call them records, which is the same thing
	here). Each row belongs to a certain type, that defines the types
	of the fields. Each field may belong to one of the simple types.
	</para>

	<sect1 id="sc_SimpleTypes">
		<title>Simple types</title>

		<indexterm>
			<primary>type</primary>
			<secondary>simple</secondary>
		</indexterm>

		<para>
		The simple values in Triceps belong to one of the simple types:
		</para>

		<itemizedlist>
		<listitem>
		uint8
		</listitem>
		<listitem>
		int32
		</listitem>
		<listitem>
		int64
		</listitem>
		<listitem>
		float64
		</listitem>
		<listitem>
		string
		</listitem>
		</itemizedlist>

		<para>
		I like the explicit specification of the data size, so it's not some
		mysterious <quote>double</quote> but an explicit <quote>float64</quote>.
		</para>

		<para>
		When the data is stored in the rows, it's stored in the strongly-typed
		binary format. When it's extracted from the rows for the Perl code to
		access, it gets converted into the Perl values. And the other way
		around, when stored into the rows, the conversion is done from the Perl
		values.
		</para>

		<para>
		<pre>uint8</pre> is the type intended to represent the raw bytes. So, for example,
		when they are compared, they should be compared as raw bytes, not
		according to the locale. Since Perl stores the raw bytes in strings,
		and its <pre>pack()</pre> and <pre>unpack()</pre> functions operate on strings, The Perl side
		of Triceps extracts the uint8 values from records into Perl strings,
		and the other way around. 
		</para>

		<para>
		The string type is intended to represent a text string in whatever
		current locale (at some point it may become always UTF-8, this question
		is open for now).
		</para>

		<para>
		Perl on the 32-bit machines has an issue with int64: it has no type to
		represent it directly. Because of that, when the int64 values are
		passed to Perl on the 32-bit machines, they are converted into the
		floating-point numbers. This gives only 54 bits (including sign) of
		precision, but that's close enough. Anyway, the 32-bit machines are
		obsolete by now, and Triceps it targeted towards the 64-bit machines.
		</para>

		<para>
		On the 64-bit machines both int32 and int64 translate to the Perl
		64-bit integers.
		</para>

		<para>
		Note that there is no special type for timestamps. As of version 1.0
		there is no time-based processing inside Triceps, but that does not
		prevent you from passing around timestamps as data and use them in your
		logic. Just store the timestamps as integers (or, if you prefer,
		as floating point numbers). When the time-based processing will be
		added to Perl, the plan is to still use the int64 to store the number
		of microseconds since the Unix epoch. My experience with the time types
		in the other CEP systems is that they cause nothing but confusion.
		</para>
	</sect1>

	<sect1 id="sc_RowTypes">
		<title>Row types</title>

		<indexterm>
			<primary>type</primary>
			<secondary>row</secondary>
		</indexterm>
		<indexterm>
			<primary>RowType</primary>
		</indexterm>
		<para>
		A row type is created from a sequence of (field-name, field-type)
		string pairs, for example:
		</para>

<pre>
$rt1 = Triceps::RowType->new(
	a => "uint8",
	b => "int32",
	c => "int64",
	d => "float64",
	e => "string",
);
</pre>

		<para>
		Even though the pairs look like a hash, don't use an actual hash to
		create row types! The order of pairs in a hash is unpredictable, while
		the order of fields in a row type usually matters.
		</para>

		<para>
		In an actual row the field may have a value or be NULL. The NULLs are
		represented in Perl as <pre>undef</pre>.
		</para>

		<indexterm>
			<primary>type</primary>
			<secondary>array</secondary>
		</indexterm>
		<indexterm>
			<primary>arrays</primary>
		</indexterm>
		<para>
		The real-world records tend to be pretty wide and contain
		repetitive data. Hundreds of fields are not unusual, and I know of a
		case when an Aleri customer wanted to have records of two thousand
		fields (and succeeded). This just begs for arrays. So the Triceps rows
		allow the array fields. They are specified by adding <quote>[]</quote> at the end of
		field type. The arrays may only be made up of fixed-width data, so no
		arrays of strings.
		</para>

<pre>
$rt2 = Triceps::RowType->new(
	a => "uint8[]",
	b => "int32[]",
	c => "int64[]",
	d => "float64[]",
	e => "string", # no arrays of strings!
) or die "$!";
</pre>

		<indexterm>
			<primary>arrays</primary>
			<secondary>empty</secondary>
		</indexterm>
		<para>
		The arrays are of variable length, whatever array data passed when a
		row is created determines its length. The individual elements in the
		array may not be NULL (and if undefs are passed in the array used to
		construct the row, they will be replaced with 0s). The whole array
		field may be NULL, and this situation is equivalent to an empty array.
		</para>

		<para>
		The type uint8 is typically used in arrays, <quote>uint8[]</quote> is the Triceps
		way to define a blob field. In Perl the <quote>uint8[]</quote> is represented as a
		string value, same as a simple <quote>unit8</quote>.
		</para>

		<para>
		The rest of array values are represented in Perl as references to Perl
		arrays, containing the actual values.
		</para>

		<para>
		The row type objects provide a way for introspection:
		</para>

<pre>
$rt->getdef()
</pre>

		<para>
		returns back the array of pairs used to create this type. It can be
		used among other things for the schema inheritance. For example, the
		multi-part messages with daily unique ids can be defined as:
		</para>

<pre>
$rtMsgKey = Triceps::RowType->new(
	date => "string",
	id => "int32",
) or die "$!";

$rtMsg = Triceps::RowType->new(
	$rtMsgKey->getdef(),
	from => "string",
	to => "string",
	subject => "string",
) or die "$!";

$rtMsgPart = Triceps::RowType->new(
	$rtMsgKey->getdef(),
	type => "string",
	payload => "string",
) or die "$!";
</pre>

		<para>
		The meaning here is the same as in the CCL example:
		</para>

<pre>
create schema rtMsgKey (
	string date,
	integer id
);
create schema rtMsg inherits from rtMsgKey (
	string from,
	string to,
	string subject
);
create schema rtMsgPart inherits from rtMsgKey (
	string type,
	string payload
);
</pre>

		<para>
		The grand plan is to provide some better ways of defining the
		commonality of fields between row types. It should include the ability
		to rename fields, to avoid conflicts, and to remember this equivalence
		to be reused in the further joins without the need to write it over and
		over again. But it has not come to the implementation stage yet.
		</para>

		<para>
		The other methods are:
		</para>

<pre>
$rt->getFieldNames()
</pre>

		<para>
		returns the array of field names only.
		</para>

<pre>
$rt->getFieldTypes()
</pre>

		<para>
		returns the array of field types only.
		</para>

<pre>
$rt->getFieldMapping()
</pre>

		<para>
		returns the array of pairs that map the field names to their indexes in
		the field definitions. It can be stored into a hash and used for
		name-to-index translation. It's used mostly in the templates, to
		generate code that accesses data in the rows by field index (which is
		more efficient than access by name). For example, for <pre>rtMsgKey</pre>
		defined above it would return <pre>(date => 0, id => 1)</pre>.
		</para>
	</sect1>

	<sect1 id="sc_RowTypesEquiv">
		<title>Row types equivalence</title>

		<indexterm>
			<primary>type</primary>
			<secondary>match</secondary>
		</indexterm>
		<indexterm>
			<primary>type</primary>
			<secondary>equals</secondary>
		</indexterm>
		<indexterm>
			<primary>RowType</primary>
			<secondary>match</secondary>
		</indexterm>
		<indexterm>
			<primary>RowType</primary>
			<secondary>equals</secondary>
		</indexterm>

		<para>
		The Triceps objects are usually strongly typed. A label handles rows of
		a certain type. A table stores rows of a certain type.
		</para>

		<para>
		However there may be multiple ways to check whether a row fits for a
		certain type:
		</para>

		<itemizedlist>
		<listitem>
		It may be a row of the exact same type, created with the same RowType object.
		</listitem>
		<listitem>
		It may be a row of another type but one with the exact same definition.
		</listitem>
		<indexterm>
			<primary>case sensitivity</primary>
		</indexterm>
		<listitem>
		It may be a row of another type that has the same number of fields and
		field types but different field names. The field names (and everything
		else in Triceps) are case-sensitive.
		</listitem>
		</itemizedlist>

		<para>
		The row types may be compared for these conditions using the methods:
		</para>

<pre>
$rt1->same($rt2)
$rt1->equals($rt2)
$rt1->match($rt2)
</pre>

		<para>
		The comparisons are hierarchical: if two type references are the same,
		they would also be equal and matching; two equal types are also
		matching.
		</para>

		<para>
		Most of the objects would accept the rows of any matching type (this
		may change or become adjustable in the future). However if the rows are
		not of the same type, this check involves a performance penalty. If the
		types are the same, the comparison is limited to comparing the
		pointers. But if not, then the whole type definition has to be
		compared. So every time a row of a different type is passed, it would
		involve the overhead of type comparison.
		</para>

		<para>
		For example:
		</para>

<pre>
my @schema = (
	a => "int32",
	b => "string"
);

my $rt1 = Triceps::RowType->new(@schema) or die "$!";
# $rt2 is equal to $rt1: same field names and field types
my $rt2 = Triceps::RowType->new(@schema) or die "$!"; 
# $rt3  matches $rt1 and $rt2: same field types but different names
my $rt3 = Triceps::RowType->new(
	A => "int32",
	B => "string"
) or die "$!";

my $lab = $unit->makeDummyLabel($rt1, "lab") or die "$!";
# same type, efficient
my $rop1 = $lab->makeRowop(&Triceps::OP_INSERT,
	$rt1->makeRowArray(1, "x")) or die "$!";
# different row type, involves a comparison overhead
my $rop2 = $lab->makeRowop(&Triceps::OP_INSERT,
	$rt2->makeRowArray(1, "x")) or die "$!";
# different row type, involves a comparison overhead
my $rop3 = $lab->makeRowop(&Triceps::OP_INSERT,
	$rt3->makeRowArray(1, "x")) or die "$!";
</pre>

		<para>
		A dummy label used here is a label that does nothing (its usefulness
		will be explained later).
		</para>

		<indexterm>
			<primary>Row</primary>
			<secondary>re-typing</secondary>
		</indexterm>
		<para>
		Once the Rowop is constructed, no further penalty is involved: the
		row in the Rowop is re-typed to the type of the label from now on.
		It's physically still the same row with another reference to it,
		but when you get it back from the Rowop, it will have the label's
		type. It's all a part of the interesting interaction between &Cpp;
		and Perl. All the type checking is done in the Perl XS layer.
		The &Cpp; code just expects that the data is always right and doesn't
		carry the types around. When the Perl code wants to get the row
		back from the Rowop, it wants to know the type of the row.
		The only way to get it is to look, what is the label of this
		Rowop, and get the row type from the label. This is also the
		reason why the types have to be checked when the Rowop is
		constructed: if a wrong row is placed into the Rowop, there will
		be no later opportunity to check it for correctness, and bad
		data may cause a crash.
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

	</sect1>

</chapter>
