<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5CR3//EN"
	"http://www.oasis-open.org/docbook/xml/4.5CR3/docbookx.dtd" [
<!ENTITY % userents SYSTEM "file:///ENTS/user.ent" >
%userents;
]>

<!--
(C) Copyright 2011-2012 Sergey A. Babkin.
This file is a part of Triceps.
See the file COPYRIGHT for the copyright notice and license information
-->

<chapter id="ch_joins" xmlns:xi="http://www.w3.org/2001/XInclude">
	<title>Joins</title>

	<sect1 id="sc_joins_variety">
		<title>Joins variety</title>

		<indexterm>
			<primary>join</primary>
		</indexterm>
		<para>
		The joins are quite important for the relational data processing, and
		come in many varieties. And the CEP systems have their own specifics.
		Basically, in CEP you want the joins to be processed fast. The CEP
		systems deal with the changing model state, and have to process these
		changes incrementally.
		</para>

		<para>
		A small change should be handled fast. It has to use the indexes to
		find and update all the related result rows. Even though you can make
		it just go sequentially through all the rows and find the relevant
		ones, like in a common database, that's not what you normally want.
		When something like this happens, the usual reaction is <quote>wtf is my
		model suddenly so slow?</quote> following by an annoyingly long investigation
		into the reasons of the slowness, and then rewriting the model to make
		it work faster. It's better to just prevent the slowness in the first
		place and make sure that the joins always use an index. And since you
		don't have to deal much with the ad-hoc queries when you write a CEP
		model, you can provide all the needed indexes in advance very easily.
		</para>

		<indexterm>
			<primary>join</primary>
			<secondary>equi-join</secondary>
		</indexterm>
		<indexterm>
			<primary>index</primary>
			<secondary>sorted</secondary>
		</indexterm>
		<indexterm>
			<primary>Aleri</primary>
		</indexterm>
		<para>
		A particularly interesting kind of joins in this regard is the
		equi-joins: ones that join the rows by the equality of the fields in
		them. They allow a very efficient index look-up. Because of this, they
		are popular in the CEP world. Some systems, like Aleri, support only
		the equi-joins to start with. The other systems are much more efficient
		on the equi-joins than on the other kinds of joins. At the moment
		Triceps follows the fashion of having the advanced support only for the
		equi-joins. Even though the Sorted/Ordered indexes in Triceps should allow the
		range-based comparisons to be efficient too, at the moment there are no
		table methods for the look-up of ranges, they are left for the future
		work. Of course, nothing stops you from copying an equi-join template
		and modifying it to work by a dumb iteration. Just it would be slow,
		and I didn't see much point in it.
		</para>

		<para>
		There also are three common patterns of the join usage.
		</para>

		<indexterm>
			<primary>Coral8</primary>
		</indexterm>
		<indexterm>
			<primary>join</primary>
			<secondary>lookup</secondary>
		</indexterm>
		<indexterm>
			<primary>join</primary>
			<secondary>stream-to-window</secondary>
		</indexterm>
		<para>
		In the first pattern the rows sort of go by and get enriched by looking
		up some information from a table and tacking it onto these rows.
		Sometimes not even tacking it on but maybe just filtering the data:
		passing through some of the rows and throwing away the rest, or
		directing the rows into the different kinds of processing, based on the
		looked-up data. For a reference, in the Coral8 CCL this situation is
		called <quote>stream-to-window joins</quote>. In Triceps there are no streams and no
		windows, so I just call them the <quote>lookup joins</quote>.
		</para>

		<indexterm>
			<primary>join</primary>
			<secondary>tables</secondary>
		</indexterm>
		<para>
		In the second pattern multiple stateful tables are joined together.
		Whenever any of the tables changes, the join result also changes, and
		the updates get propagated through. This can be done through lookups,
		but in reality it turns out that defining manually the lookups for the
		every possible table change becomes tedious pretty quickly. This has to
		be addressed by the automation.
		</para>

		<indexterm>
			<primary>join</primary>
			<secondary>self</secondary>
		</indexterm>
		<para>
		In the third pattern the same table gets joined recursively,
		essentially traversing a representation of a tree stored in that table.
		This actually doesn't work well with the classic SQL unless the
		recursion depth is strictly limited. There are SQL extensions for the
		recursive self-joins in the modern databases but I haven't seen them in the
		CEP systems yet. Anyway, the procedural approach tends to work for this
		situation much better than the SQLy one, so the templates tend to be of
		not much help. I'll show a templated and a manual example of this kind
		for comparison.
		</para>
	</sect1>

	<sect1 id="sc_joins_hello">
		<title>Hello, joins!</title>

		<para>
		As usual, let me show a couple of little teasers before starting the
		long bottom-up discussion. We'll eventually get by the long
		way to the same examples, so here I'll show only some very short
		code snippets and basic explanations.
		</para>

<!-- t/xJoin.t, doLookupFull, replaced leftFields from commented-out, removed fieldsLeftFirst, isLeft -->
<pre>
our $join = Triceps::LookupJoin->new(
	name => "join",
	leftFromLabel => $lbTrans,
	rightTable => $tAccounts,
	rightIdxPath => ["lookupSrcExt"],
	leftFields => [ "!acct.*", ".*" ],
	rightFields => [ "internal/acct" ],
	by => [ "acctSrc" => "source", "acctXtrId" => "external" ],
);
</pre>

		<indexterm>
			<primary>join</primary>
			<secondary>lookup</secondary>
		</indexterm>
		<para>
		This is a lookup join that gets the incoming rows with transactions
		data from the label <pre>$lbTrans</pre>, finds the account translation in the
		table <pre>$tAccounts</pre>, and translates the external account representation
		to internal one on its output. The join condition is an equivalent of the
		SQLy
		</para>

		<indexterm>
			<primary>SQL</primary>
		</indexterm>
<pre>
on 
	lbTrans.acctSrc = tAccounts.source
	and lbTrans.acctXtrId = tAccounts.external
</pre>

		<para>
		The condition looks up the rows in <pre>$tAccounts</pre> using the index <pre>lookupSrcExt</pre>
		that must have the key fields <pre>source</pre> and <pre>external</pre>.
		</para>

		<para>
		The result fields will contain all the fields from <pre>$lbTrans</pre> except those
		starting with <quote>acct</quote> plus the field <pre>internal</pre> from <pre>$tAccounts</pre>
		that becomes renamed to <pre>acct</pre>.
		</para>

		<para>
		Next goes a table join:
		</para>

<!-- t/xJoin.t, doJoinInner -->
<pre>
our $join = Triceps::JoinTwo->new(
	name => "join",
	leftTable => $tPosition,
	leftIdxPath => [ "currencyLookup" ],
	rightTable => $tToUsd,
	rightIdxPath => [ "primary" ],
	type => "inner",
);
</pre>

		<indexterm>
			<primary>join</primary>
			<secondary>tables</secondary>
		</indexterm>
		<para>
		It joins the tables <pre>$tPosition</pre> and <pre>$tToUsd</pre>, with the inner join logic.
		The table <pre>$tPosition</pre> uses its index <pre>currencyLookup</pre>, and <pre>$tToUsd</pre> uses
		its index <pre>primary</pre>. The join condition is determined by pairing the
		key fields of the indexes.
		</para>
	</sect1>

	<sect1 id="sc_joins_lookup_manual">
		<title>The lookup join, done manually</title>

		<para>
		First let's look at a lookup done manually. It would also establish the
		baseline for the further joins.
		</para>

		<para>
		For the background of the model, let's consider the trade information
		coming in from multiple sources. Each source system has its own
		designation of the accounts on which the trades happen but ultimately
		they are the same accounts. So there is a table that contains the
		translation from the account designations of various external systems
		to our system's own internal account identifier. This gets described
		with the row types:
		</para>

<!-- t/xJoin.t -->
<pre>
our $rtInTrans = Triceps::RowType->new( # a transaction received
	id => "int32", # the transaction id
	acctSrc => "string", # external system that sent us a transaction
	acctXtrId => "string", # its name of the account of the transaction
	amount => "int32", # the amount of transaction (int is easier to check)
) or confess "$!";

our $rtAccounts = Triceps::RowType->new( # account translation map
	source => "string", # external system that sent us a transaction
	external => "string", # its name of the account in the transaction
	internal => "int32", # our internal account id
) or confess "$!";
</pre>

		<para>
		Other than those basics, the rest of information is only minimal, to
		keep the examples smaller. Even the trade ids are expected to be global
		and not per the source systems (which is not realistic but saves
		another little bit of work).
		</para>

		<para>
		The accounts table can be indexed in multiple ways for multiple
		purposes, say:
		</para>

<!-- t/xJoin.t -->
<pre>
our $ttAccounts = Triceps::TableType->new($rtAccounts)
	->addSubIndex("lookupSrcExt", # quick look-up by source and external id
		Triceps::IndexType->newHashed(key => [ "source", "external" ])
	)
	->addSubIndex("iterateSrc", # for iteration in order grouped by source
		Triceps::IndexType->newHashed(key => [ "source" ])
		->addSubIndex("iterateSrcExt", 
			Triceps::IndexType->newHashed(key => [ "external" ])
		)
	)
	->addSubIndex("lookupIntGroup", # quick look-up by internal id (to multiple externals)
		Triceps::IndexType->newHashed(key => [ "internal" ])
		->addSubIndex("lookupInt", Triceps::IndexType->newFifo())
	)
or confess "$!";
$ttAccounts->initialize() or confess "$!";
</pre>

		<para>
		For our purpose of joining, the first, primary key is the way to go.
		Using the primary key also has the advantage of making sure that there
		is no more than one row for each key value.
		</para>

		<indexterm>
			<primary>join</primary>
			<secondary>manual lookup</secondary>
		</indexterm>
		<indexterm>
			<primary>join</primary>
			<secondary>filter</secondary>
		</indexterm>
		<indexterm>
			<primary>join</primary>
			<secondary>lookup</secondary>
		</indexterm>
		<para>
		The first manual lookup example will just do the filtering: find, whether there is a match
		in the translation table, and if so then pass the row through. The
		example goes as follows:
		</para>

<!-- t/xJoin.t, doManualLookup -->
<pre>
our $uJoin = Triceps::Unit->new("uJoin");

our $tAccounts = $uJoin->makeTable($ttAccounts, 
	"EM_CALL", "tAccounts") or confess "$!";

my $lbFilterResult = $uJoin->makeDummyLabel($rtInTrans, "lbFilterResult");
my $lbFilter = $uJoin->makeLabel($rtInTrans, "lbFilter", undef, sub {
	my ($label, $rowop) = @_;
	my $row = $rowop->getRow();
	my $rh = $tAccounts->findBy(
		source => $row->get("acctSrc"),
		external => $row->get("acctXtrId"),
	);
	if (!$rh->isNull()) {
		$uJoin->call($lbFilterResult->adopt($rowop));
	}
}) or confess "$!";

# label to print the changes to the detailed stats
makePrintLabel("lbPrint", $lbFilterResult);

while(&readLine) {
	chomp;
	my @data = split(/,/); # starts with a command, then string opcode
	my $type = shift @data;
	if ($type eq "acct") {
		$uJoin->makeArrayCall($tAccounts->getInputLabel(), @data);
	} elsif ($type eq "trans") {
		$uJoin->makeArrayCall($lbFilter, @data);
	}
	$uJoin->drainFrame(); # just in case, for completeness
}
</pre>

		<para>
		The <pre>findBy()</pre> is where the join actually happens: the lookup of the data
		in a table by values from another row. Very similar to what the
		basic window example in
		<xref linkend="sc_table_hello" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;
		was doing before. It's <pre>findBy()</pre>, without the need for <pre>findByIdx()</pre>,
		because in this case the index type used in the accounts table is its
		first leaf index, to which <pre>findBy()</pre> defaults.
		After that the fact of
		successful or unsuccessful lookup is used to pass the original row
		through or throw it away. If the found row were used to pick some
		fields from it and stick them into the result, that would be a more
		complete join, more like what you often expect to see.
		</para>

		<para>
		And here is an example of the input processing:
		</para>

<!-- t/xJoin.t, doManualLookup -->
<exdump>
> acct,OP_INSERT,source1,999,1
> acct,OP_INSERT,source1,2011,2
> acct,OP_INSERT,source2,ABCD,1
> trans,OP_INSERT,1,source1,999,100
lbFilterResult OP_INSERT id="1" acctSrc="source1" acctXtrId="999" amount="100" 
> trans,OP_INSERT,2,source2,ABCD,200
lbFilterResult OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD" amount="200" 
> trans,OP_INSERT,3,source2,QWERTY,200
> acct,OP_INSERT,source2,QWERTY,2
> trans,OP_DELETE,3,source2,QWERTY,200
lbFilterResult OP_DELETE id="3" acctSrc="source2" acctXtrId="QWERTY" amount="200" 
> acct,OP_DELETE,source1,999,1
</exdump>

		<para>
		It starts with populating the accounts table. Then the transactions that
		find the match pass, and those who don't find don't pass. If more of
		the account translations get added later, the transactions for them
		start passing but as you can see, the result might be slightly
		unexpected: you may get a DELETE that had no matching previous INSERT,
		as happened for the row with id=3.
		This happens because the lookup join keeps no history on its left side
		and can't react properly to the changes to the table on the right.
		Because of this, the lookup joins work best when the reference table
		gets pre-populated in advance and then stays stable.
		</para>
	</sect1>

	<sect1 id="sc_joins_lookupjoin">
		<title>The LookupJoin template</title>

		<indexterm>
			<primary>template</primary>
		</indexterm>
		<indexterm>
			<primary>LookupJoin</primary>
		</indexterm>
		<para>
		When a join has to produce the new rows, with the data from both the
		incoming row and the ones looked up in the reference table, this can
		also be done manually but may be more convenient to do with the
		LookupJoin template. The translation of account to the internal ids can
		be done like this:
		</para>

<!-- t/xJoin.t, doLookupLeft, removed saveJoinerTo -->
<pre>
our $join = Triceps::LookupJoin->new(
	unit => $uJoin,
	name => "join",
	leftRowType => $rtInTrans,
	rightTable => $tAccounts,
	rightIdxPath => ["lookupSrcExt"],
	rightFields => [ "internal/acct" ],
	by => [ "acctSrc" => "source", "acctXtrId" => "external" ],
	isLeft => 1,
); # would die by itself on an error

# label to print the changes to the detailed stats
makePrintLabel("lbPrint", $join->getOutputLabel());

while(&readLine) {
	chomp;
	my @data = split(/,/); # starts with a command, then string opcode
	my $type = shift @data;
	if ($type eq "acct") {
		$uJoin->makeArrayCall($tAccounts->getInputLabel(), @data);
	} elsif ($type eq "trans") {
		$uJoin->makeArrayCall($join->getInputLabel(), @data);
	}
	$uJoin->drainFrame(); # just in case, for completeness
}
</pre>

		<para>
		The join gets defined in the option name-value format. The options <quote>unit</quote> and
		<quote>name</quote> are as usual.
		</para>

		<para>
		The incoming rows are always on the left side, the table on the right.
		LookupJoin can do either the inner join or the left outer join (since
		it does not react to the changes of the right table and has no access
		to the past data from the left side, the full and right outer joins are not
		available).
		In this case the option <quote>isLeft => 1</quote> selects the left outer join.
		The left outer join also happens to be the default if this option is not used.
		</para>

		<para>
		The left side is described by the option <quote>leftRowType</quote>, and causes the join's input
		label of this row type to be created. The input label can be found with
		<pre>$join->getInputLabel()</pre>.
		</para>

		<para>
		The right side is a table, specified in the option <quote>rightTable</quote>. The
		lookups in the table are done using a combination of an index and the
		field pairing. The option <quote>by</quote> provides the field pairing. It contains
		the pairs of field names, one from the left, and one from the right,
		for the equal fields. They can be separated by 
		<quote><pre>,</pre></quote> too, but <quote><pre>=></pre></quote>
		feels more idiomatic to me. These fields from the left are translated
		to the right and are used for lookup through the index. The index
		is specified with the path in the option <quote>rightIdxPath</quote>. If this
		option is missing, LookupJoin will just try to find the first top-level
		Hashed index. Either way, the index must be a Hashed index.
		</para>

		<indexterm>
			<primary>index</primary>
			<secondary>hashed</secondary>
		</indexterm>
		<indexterm>
			<primary>index</primary>
			<secondary>sorted</secondary>
		</indexterm>
		<indexterm>
			<primary>LookupJoin</primary>
			<secondary>keys</secondary>
		</indexterm>
		<para>
		There is no particular reason for it not being a Sorted/Ordered index, other
		that the <pre>getKey()</pre> call does not work for these indexes yet, and
		that's what the LookupJoin uses to check that the right-side index key
		matches the join key in <quote>by</quote>. The order of the fields in the
		option <quote>by</quote> and in the index may vary but the set of the
		fields must be the same.
		</para>

		<para>
		The index may be either a leaf (as in this example) or non-leaf. If
		it's a leaf, it could look up no more than one row per key, and
		LookupJoin uses this internally for a little optimization. Otherwise
		LookupJoin is capable of producing multiple result rows for one input row.
		</para>

		<indexterm>
			<primary>projection</primary>
		</indexterm>
		<indexterm>
			<primary>result filtering</primary>
		</indexterm>
		<para>
		Finally, there is the result row. It is built out of the two original
		rows by picking the fields according to the options <quote>leftFields</quote> and
		<quote>rightFields</quote>. If either option is missing, that means 
		<quote>take all the fields</quote>. 
		The format of these options is from <pre>Triceps::Fields::filterToPairs()</pre>
		that has been described in
		<xref linkend="sc_template_result" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;.
		So in this example <pre>[ "internal/acct" ]</pre> means: pass the field <pre>internal</pre>
		but rename it to <pre>acct</pre>.
		</para>

		<para>
		Remember that the field names in the result must not
		duplicate. It would be an error. So if the duplications happen, use the
		substitution syntax to rename some of the fields.
		</para>

		<para>
		A fairly common usage in joins is to just give the unique prefixes to
		the left-side and right-side fields. This can be achieved with:
		</para>

<pre>
	leftFields => [ '.*/left_$&' ],
	rightFields => [ '.*/right_$&' ],
</pre>

		<para>
		The <pre>$&</pre> in the substitution gets replaced with the whole matched
		field name.
		</para>

		<para>
		The option <quote>fieldsLeftFirst</quote> determines, which side will go first in
		the result. By default it's set to 1 (as in this example), and the left
		side goes first. If set to 0, the right side would go first.
		</para>

		<para>
		This setup for the result row types is somewhat clumsy but it's a
		reasonable first attempt. 
		</para>

		<para>
		Now, having gone through the description, an example of how it works:
		</para>

<!-- t/xJoin.t, doLookupLeft -->
<exdump>
> acct,OP_INSERT,source1,999,1
> acct,OP_INSERT,source1,2011,2
> acct,OP_INSERT,source2,ABCD,1
> trans,OP_INSERT,1,source1,999,100
join.out OP_INSERT id="1" acctSrc="source1" acctXtrId="999" amount="100" acct="1" 
> trans,OP_INSERT,2,source2,ABCD,200
join.out OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD" amount="200" acct="1" 
> trans,OP_INSERT,3,source2,QWERTY,200
join.out OP_INSERT id="3" acctSrc="source2" acctXtrId="QWERTY" amount="200" 
> acct,OP_INSERT,source2,QWERTY,2
> trans,OP_DELETE,3,source2,QWERTY,200
join.out OP_DELETE id="3" acctSrc="source2" acctXtrId="QWERTY" amount="200" acct="2" 
> acct,OP_DELETE,source1,999,1
</exdump>

		<para>
		Same as before, first the accounts table gets populated, then the
		transactions are sent. If an account is not found, this left outer join
		still passes through the original fields from the left side. Adding an
		account later doesn't help the rowops that already went through but the
		new rowops will see it. The same goes for deleting an account, it
		doesn't affect the past rowops either.
		</para>

		<para>
		The left-side data can also be specified in another way: the option
		<quote>leftFromLabel</quote> provides a label which in turn provides both the input
		row type and the unit. You can still specify the unit option as well
		but it must match the one in the label. This is driven internally by
		<pre>Triceps::Opt::handleUnitTypeLabel()</pre>, described in
		<xref linkend="sc_template_options" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;,
		so it follows the same rules.
		The join still has its own
		input label but it gets automatically chained to the one in the option.
		For an example of such a join:
		</para>

<!-- t/xJoin.t, doLookupFull, removed commented-out stuff -->
<pre>
our $lbTrans = $uJoin->makeDummyLabel($rtInTrans, "lbTrans");

our $join = Triceps::LookupJoin->new(
	name => "join",
	leftFromLabel => $lbTrans,
	rightTable => $tAccounts,
	rightIdxPath => ["lookupSrcExt"],
	leftFields => [ "id", "amount" ],
	fieldsLeftFirst => 0,
	rightFields => [ "internal/acct" ],
	by => [ "acctSrc" => "source", "acctXtrId" => "external" ],
	isLeft => 0,
); # would die by itself on an error

# label to print the changes to the detailed stats
makePrintLabel("lbPrint", $join->getOutputLabel());

while(&readLine) {
	chomp;
	my @data = split(/,/); # starts with a command, then string opcode
	my $type = shift @data;
	if ($type eq "acct") {
		$uJoin->makeArrayCall($tAccounts->getInputLabel(), @data);
	} elsif ($type eq "trans") {
		$uJoin->makeArrayCall($lbTrans, @data);
	}
	$uJoin->drainFrame(); # just in case, for completeness
}
</pre>

		<para>
		The other options demonstrate the possibilities described in the last
		post. This time it's an inner join, the result has the right-side
		fields going first, and the left-side fields are filtered in the
		result by an explicit list of fields to pass.
		</para>

		<para>
		Another way to achieve the same filtering of the left-side fields would
		be by throwing away everything starting with <quote>acct</quote> and passing through
		the rest:
		</para>

<pre>
	leftFields => [ "!acct.*", ".*" ],
</pre>

		<para>
		And here is an example of a run:
		</para>

<!-- t/xJoin.t, doLookupFull -->
<exdump>
> acct,OP_INSERT,source1,999,1
> acct,OP_INSERT,source1,2011,2
> acct,OP_INSERT,source2,ABCD,1
> trans,OP_INSERT,1,source1,999,100
join.out OP_INSERT acct="1" id="1" amount="100" 
> trans,OP_INSERT,2,source2,ABCD,200
join.out OP_INSERT acct="1" id="2" amount="200" 
> trans,OP_INSERT,3,source2,QWERTY,200
> acct,OP_INSERT,source2,QWERTY,2
> trans,OP_DELETE,3,source2,QWERTY,200
join.out OP_DELETE acct="2" id="3" amount="200" 
> acct,OP_DELETE,source1,999,1
</exdump>

		<para>
		The input data is the same as the last time, but the result is
		different. Since it's an inner join, the rows that don't find a match
		don't pass through. And of course the fields are ordered and subsetted
		differently in the result.
		</para>

		<para>
		The next example loses all connection with reality, it just serves to
		demonstrate another ability of LookupJoin: matching multiple rows on
		the right side for an incoming row. The situation itself is obviously
		useful and normal, just it's not what normally happens with the
		account id translation, and I was too lazy to invent another
		realistically-looking example.
		</para>

<!-- t/xJoin.t, doLookupLeftMulti and the type def before it, removed saveJoinerTo -->
<pre>
our $ttAccounts2 = Triceps::TableType->new($rtAccounts)
	->addSubIndex("iterateSrc", # for iteration in order grouped by source
		Triceps::IndexType->newHashed(key => [ "source" ])
		->addSubIndex("lookupSrcExt",
			Triceps::IndexType->newHashed(key => [ "external" ])
			->addSubIndex("grouping", Triceps::IndexType->newFifo())
		)
	)
or confess "$!";
$ttAccounts2->initialize() or confess "$!";

our $tAccounts = $uJoin->makeTable($ttAccounts2, 
	"EM_CALL", "tAccounts") or confess "$!";

our $join = Triceps::LookupJoin->new(
	unit => $uJoin,
	name => "join",
	leftRowType => $rtInTrans,
	rightTable => $tAccounts,
	rightIdxPath => [ "iterateSrc", "lookupSrcExt" ],
	rightFields => [ "internal/acct" ],
	by => [ "acctSrc" => "source", "acctXtrId" => "external" ],
); # would die by itself on an error
</pre>

		<para>
		The main loop is unchanged from the first LookupJoin example, so I
		wont' copy it here. Just for something different, the join index here
		is nested, and its path consists of two elements. It's not a leaf index
		either, with one FIFO level under it. And when the <quote>isLeft</quote> is not
		specified explicitly, it defaults to 1, making it a left join.
		</para>

		<para>
		The example of a run uses a slightly different input, highlighting the ability to
		match multiple rows:
		</para>

<!-- t/xJoin.t, doLookupLeftMulti -->
<exdump>
> acct,OP_INSERT,source1,999,1
> acct,OP_INSERT,source1,2011,2
> acct,OP_INSERT,source2,ABCD,1
> acct,OP_INSERT,source2,ABCD,10
> acct,OP_INSERT,source2,ABCD,100
> trans,OP_INSERT,1,source1,999,100
join.out OP_INSERT id="1" acctSrc="source1" acctXtrId="999" amount="100" acct="1" 
> trans,OP_INSERT,2,source2,ABCD,200
join.out OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD" amount="200" acct="1" 
join.out OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD" amount="200" acct="10" 
join.out OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD" amount="200" acct="100" 
> trans,OP_INSERT,3,source2,QWERTY,200
join.out OP_INSERT id="3" acctSrc="source2" acctXtrId="QWERTY" amount="200" 
> acct,OP_INSERT,source2,QWERTY,2
> trans,OP_DELETE,3,source2,QWERTY,200
join.out OP_DELETE id="3" acctSrc="source2" acctXtrId="QWERTY" amount="200" acct="2" 
> acct,OP_DELETE,source1,999,1
</exdump>

		<para>
		When a row matches multiple rows in the table, it gets multiplied. The
		join function iterates through the whole matching row group, and for
		each found row creates a result row and calls the output label with it.
		</para>

		<para>
		Now, what if you don't want to get multiple rows back even if they are
		found? Of course, the best way is to just use a leaf index. But once in
		a while you get into situations with the denormalized data in the
		lookup table. You might know in advance that for each row in an index
		group a certain field would be the same. Or you might not care, what
		exact value you get as long as it's from the right group. But you might
		really not want the input rows to multiply when they go through the
		join. LookupJoin has a solution:
		</para>

<!-- t/xJoin.t, doLookupLeftMultiOne -->
<pre>
our $join = Triceps::LookupJoin->new(
	unit => $uJoin,
	name => "join",
	leftRowType => $rtInTrans,
	rightTable => $tAccounts,
	rightIdxPath => [ "iterateSrc", "lookupSrcExt" ],
	rightFields => [ "internal/acct" ],
	by => [ "acctSrc" => "source", "acctXtrId" => "external" ],
	limitOne => 1,
); # would die by itself on an error
</pre>

		<para>
		The option <quote>limitOne</quote> changes the processing logic to pick only the
		first matching row. It also optimizes the join function. If <quote>limitOne</quote> is
		not specified explicitly, the join constructor deduces it magically by
		looking at whether the join index is a leaf or not. Actually, for a
		leaf index it would always override <quote>limitOne</quote> to 1, even if you
		explicitly set it to 0.
		</para>

		<para>
		With the limit, the same input produces a different output:
		</para>

<!-- t/xJoin.t, doLookupLeftMultiOne -->
<exdump>
> acct,OP_INSERT,source1,999,1
> acct,OP_INSERT,source1,2011,2
> acct,OP_INSERT,source2,ABCD,1
> acct,OP_INSERT,source2,ABCD,10
> acct,OP_INSERT,source2,ABCD,100
> trans,OP_INSERT,1,source1,999,100
join.out OP_INSERT id="1" acctSrc="source1" acctXtrId="999" amount="100" acct="1" 
> trans,OP_INSERT,2,source2,ABCD,200
join.out OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD" amount="200" acct="1" 
> trans,OP_INSERT,3,source2,QWERTY,200
join.out OP_INSERT id="3" acctSrc="source2" acctXtrId="QWERTY" amount="200" 
> acct,OP_INSERT,source2,QWERTY,2
> trans,OP_DELETE,3,source2,QWERTY,200
join.out OP_DELETE id="3" acctSrc="source2" acctXtrId="QWERTY" amount="200" acct="2" 
> acct,OP_DELETE,source1,999,1
</exdump>

		<para>
		Now it just picks the first matching row instead of multiplying the
		rows.
		</para>
	</sect1>

	<sect1 id="sc_joins_lookupjoin_iter">
		<title>Manual iteration with LookupJoin</title>

		<indexterm>
			<primary>LookupJoin</primary>
		</indexterm>
		<indexterm>
			<primary>join</primary>
			<secondary>manual iteration</secondary>
		</indexterm>

		<para>
		Sometimes you might want to just get the list of the resulting rows
		from LookupJoin and iterate over them by yourself, rather than have it
		call the labels. To be honest, this looked kind of important when I
		wrote LookupJoin first, but by now I don't see a whole lot of use in
		it. By now, if you want to do a manual iteration, calling <pre>findBy()</pre> and
		then iterating looks like a more useful option. But at the time there
		was no <pre>findBy()</pre>, and this feature came to exist. Here is an example:
		</para>

<!-- t/xJoin.t, doLookupLeftManual, removed saveJoinerTo -->
<pre>
our $join = Triceps::LookupJoin->new(
	unit => $uJoin,
	name => "join",
	leftRowType => $rtInTrans,
	rightTable => $tAccounts,
	rightIdxPath => ["lookupSrcExt"],
	rightFields => [ "internal/acct" ],
	by => [ "acctSrc" => "source", "acctXtrId" => "external" ],
	automatic => 0,
); # would die by itself on an error

# label to print the changes to the detailed stats
my $lbPrint = makePrintLabel("lbPrint", $join->getOutputLabel());

while(&readLine) {
	chomp;
	my @data = split(/,/); # starts with a command, then string opcode
	my $type = shift @data;
	if ($type eq "acct") {
		$uJoin->makeArrayCall($tAccounts->getInputLabel(), @data);
	} elsif ($type eq "trans") {
		my $op = shift @data; # drop the opcode field
		my $trans = $rtInTrans->makeRowArray(@data) or confess "$!";
		my @rows = $join->lookup($trans);
		foreach my $r (@rows) {
			$uJoin->call($lbPrint->makeRowop($op, $r)) or confess "$!";
		}
	}
	$uJoin->drainFrame(); # just in case, for completeness
}
</pre>

		<para>
		It copies the first LookupJoin example, only now with a manual iteration. Once the
		option <quote>automatic</quote> is set to 0 for the join, the method
		<pre>$join->lookup()</pre> becomes available to perform the lookup and return
		the result rows in an array (the data sent to the input label keeps
		working as usual, sending the result rows to the output label). This
		involves the extra overhead of keeping all the result rows (and there
		might be lots of them) in an array, so by default the join is compiled
		in an automatic-only mode.
		</para>

		<para>
		Since <pre>lookup()</pre> returns rows, not rowops, and knows nothing
		about the opcodes, those had to be handled separately around the lookup.
		</para>

		<para>
		The result is the same as for the first example, only the name of the
		result label differs:
		</para>

<!-- t/xJoin.t, doLookupLeftManual -->
<exdump>
> acct,OP_INSERT,source1,999,1
> acct,OP_INSERT,source1,2011,2
> acct,OP_INSERT,source2,ABCD,1
> trans,OP_INSERT,1,source1,999,100
lbPrint OP_INSERT id="1" acctSrc="source1" acctXtrId="999" amount="100" acct="1" 
> trans,OP_INSERT,2,source2,ABCD,200
lbPrint OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD" amount="200" acct="1" 
> trans,OP_INSERT,3,source2,QWERTY,200
lbPrint OP_INSERT id="3" acctSrc="source2" acctXtrId="QWERTY" amount="200" 
> acct,OP_INSERT,source2,QWERTY,2
> trans,OP_DELETE,3,source2,QWERTY,200
lbPrint OP_DELETE id="3" acctSrc="source2" acctXtrId="QWERTY" amount="200" acct="2" 
> acct,OP_DELETE,source1,999,1
</exdump>

		<para>
		The print label is still connected to the output label of the LookupJoin,
		but it's done purely for the convenience of its creation. Since no rowops
		get sent to the LookupJoin's input, none get to its output, and none
		get from there to the output label. Instead the main loop creates and sends the
		rowops directly to the output label when it iterates through the lookup
		results. Because of this the label name in the output is the name of
		the output label.
		</para>
	</sect1>

	<sect1 id="sc_joins_lookupjoin_keys">
		<title>The key fields of LookupJoin</title>

		<indexterm>
			<primary>LookupJoin</primary>
			<secondary>keys</secondary>
		</indexterm>
		<para>
		The key fields are the ones that participate in the join condition.
		I use these terms interchangeably because by the definition of
		LookupJoin, these fields must be the key fields in the join index
		in the right-side table. LookupJoin has a few more facilities for their
		handling that haven't been shown yet.
		</para>

		<para>
		First, the join condition can be specified as the
		<pre>Triceps::Fields::filterToPairs()</pre> patterns in the option
		<quote>byLeft</quote>. The options <quote>by</quote> and
		<quote>byLeft</quote> are mutually exclusive and one of them
		must be present. The condition
		</para>

<pre>
by => [ "acctSrc" => "source", "acctXtrId" => "external" ],
</pre>

		<para>
		can be also specified as:
		</para>

<pre>
byLeft => [ "acctSrc/source", "acctXtrId/external" ],
</pre>

		<para>
		The option name <quote>byLeft</quote> says that the pattern specification is for the
		fields on the left side (there is no symmetric <quote>byRight</quote>). The
		substitutions produce the matching field names for the right side.
		Unlike the result pattern, here the fields that do not find a match do
		not get included in the key. It's as if an implicit <pre>"!.*"</pre> gets added at
		the end. In fact, <pre>"!.*"</pre> really does get added implicitly at the end.
		</para>

		<para>
		Of course, for the example above either option doesn't make much
		difference. It starts making the difference when the key fields follow
		a pattern. For example, if the key fields on both sides have the names
		<pre>acctSrc</pre> and <pre>acctXtrId</pre>, the specification with the <quote>byLeft</quote>
		becomes a little simpler:
		</para>

<pre>
byLeft => [ "acctSrc", "acctXtrId" ],
</pre>

		<para>
		Even more so if the key is long, common on both sides, and all the
		fields have a common prefix. Such as:
		</para>

<pre>
k_AccountSystem
k_AccountId
k_InstrumentSystem
k_InstrumentId
k_TransactionDate
k_SettlementDate
</pre>

		<para>
		Then the join condition can be specified simply as:
		</para>

<pre>
byLeft => [ "k_.*" ],
</pre>

		<para>
		If say the settlement date doesn't matter for a particular join, it can be excluded:
		</para>

<pre>
byLeft => [ "!k_SettlementDate", "k_.*" ],
</pre>

		<para>
		If the right side represents a swap of securities, it might have two
		parts to it, each describing its half with its key:
		</para>

<pre>
BorrowAccountSystem
BorrowAccountId
BorrowInstrumentSystem
BorrowInstrumentId
BorrowTransactionDate
BorrowSettlementDate
LoanAccountSystem
LoanAccountId
LoanInstrumentSystem
LoanInstrumentId
LoanTransactionDate
LoanSettlementDate
</pre>

		<para>
		Then the join of the one-sided rows with the borrow part condition can be done using:
		</para>

<pre>
byLeft => [ 'k_(.*)/Borrow$1' ],
</pre>

		<para>
		The key patterns make the long keys easier to drag around.
		</para>

		<indexterm>
			<primary>keys</primary>
			<secondary>type conversion</secondary>
		</indexterm>
		<para>
		Second, key fields of LookupJoin don't have to be of the same type on
		the left and on the right side. Since the key building for lookup is
		done through Perl, the key values get automatically converted as
		needed. 
		</para>

		<para>
		A caveat is that the conversion might be not exactly direct. If a
		string gets converted to a number, then any string values that do not
		look like numbers will be converted to 0. A conversion between a string
		and a floating-point number, in either direction, is likely to lose
		precision. A conversion between int64 and int32 may cause the upper
		bits to be truncated. So what gets looked up may be not what you
		expect.
		</para>

		<para>
		I'm not sure yet if I should add the requirement for the types being
		exactly the same. The automatic conversions seem to be convenient, just
		use them with care. I suppose, when the joins will get eventually
		implemented in the &Cpp; code, this freedom would go away because it's
		much easier and more efficient in &Cpp; to copy the field values as-is
		than to convert them.
		</para>

		<para>
		The only thing currently checked is whether a field is represented in
		Perl as a scalar or an array, and that must match on the left and on
		the right. Note that the array <pre>uint8[]</pre> gets represented in Perl as a
		scalar string, so an <pre>uint8[]</pre> field can be matched with other scalars
		but not with the other arrays.
		</para>

		<para>
		Third, the key fields have the problem of duplication. The LookupJoin is
		by definition an equi-join, it joins together the rows that have the
		same values in a set of key fields. If all the fields from both sides
		are to be included in the result, they key values will be present in it
		twice, once from the left side, once from the right side. This is not
		what is usually wanted, and the good practice is to let these fields
		through from one side and filter out from the other side.
		</para>

		<para>
		Letting these fields through on the left side is usually the better
		choice. For the inner joins it doesn't really matter but for the
		left outer joins it works much better than the with letting through
		the fields from the right side. The reason is that when the join
		doesn't find the match on the right side, all the right-side
		fields will be NULL. If you pass through the key fields only from the
		right side, they will contain NULL, and this is probably not what
		you want.
		</para>

		<para>
		However if for some reason, be it the order of the fields or the
		better field types on the right side, you really want to pass the
		key fields only from the right side, you can. LookupJoin provides
		a special magic act enabled by the option
		</para>

<pre>
	fieldsMirrorKey => 1
</pre>

		<para>
		Then if the row is not found on the right side, a special right-side
		row will be created with the key fields copied from the left side,
		and it will be used to produce the result row. With
		<quote>fieldsMirrorKey</quote> you are guaranteed to always have the
		key values present on the right side.
		</para>
	</sect1>

	<sect1 id="sc_joins_lookupjoin_inside">
		<title>A peek inside LookupJoin</title>

		<indexterm>
			<primary>LookupJoin</primary>
			<secondary>code generation</secondary>
		</indexterm>
		<para>
		I won't be describing in the details the internals of LookupJoin. They
		seem a bit too big and complicated. Partially it's because the code is
		of an older origin, and not using all the newer calls. Partially it's
		because when I wrote it, I've tried to optimize by translating the rows
		to an array format instead of referring to the fields by names, and
		that made the code more tricky. Partially, the code has grown more
		complex due to all the added options. And partially the functionality
		just is a little tricky by itself.
		</para>

		<para>
		But, for debugging purposes, the LookupJoin constructor can return the
		auto-generated code of the joiner function. It's done with the option
		<quote>saveJoinerTo</quote>:
		</para>

<pre>
	saveJoinerTo => \$code,
</pre>

		<para>
		This will cause the auto-generated code to be placed into the variable
		<pre>$code</pre>. I've collected a few such examples in this section.
		They provide a glimpse into the internal workings of the
		joiner. It's definitely a quite advanced topic, but it's helpful if you
		want to know, what is really going on in there.
		</para>

		<para>
		The joiner code from the example
		</para>

<!-- t/xJoin.t, doLookupLeft, removed saveJoinerTo -->
<pre>
our $join = Triceps::LookupJoin->new(
	unit => $uJoin,
	name => "join",
	leftRowType => $rtInTrans,
	rightTable => $tAccounts,
	rightIdxPath => ["lookupSrcExt"],
	rightFields => [ "internal/acct" ],
	by => [ "acctSrc" => "source", "acctXtrId" => "external" ],
	isLeft => 1,
); # would die by itself on an error
</pre>

		<para>
		that was shown first in the
		<xref linkend="sc_joins_lookupjoin" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;
		is this:
		</para>

<pre>
sub # ($inLabel, $rowop, $self)
{
	my ($inLabel, $rowop, $self) = @_;
	#print STDERR "DEBUGX LookupJoin " . $self->{name} . " in: ", $rowop->printP(), "\n";

	my $opcode = $rowop->getOpcode(); # pass the opcode
	my $row = $rowop->getRow();

	my @leftdata = $row->toArray();

	my $resRowType = $self->{resultRowType};
	my $resLabel = $self->{outputLabel};

	my $lookuprow = $self->{rightRowType}->makeRowHash(
		source => $leftdata[1],
		external => $leftdata[2],
		);
	
	#print STDERR "DEBUGX " . $self->{name} . " lookup: ", $lookuprow->printP(), "\n";
	my $rh = $self->{rightTable}->findIdx($self->{rightIdxType}, $lookuprow);
	Carp::confess("$!") unless defined $rh;

	my @rightdata; # fields from the right side, defaults to all-undef, if no data found
	my @result; # the result rows will be collected here

	if (!$rh->isNull()) {
		#print STDERR "DEBUGX " . $self->{name} . " found data: " . $rh->getRow()->printP() . "\n";
		@rightdata = $rh->getRow()->toArray();
	}

		my @resdata = ($leftdata[0],
		$leftdata[1],
		$leftdata[2],
		$leftdata[3],
		$rightdata[2],
		);
		my $resrowop = $resLabel->makeRowop($opcode, $resRowType->makeRowArray(@resdata));
		#print STDERR "DEBUGX " . $self->{name} . " +out: ", $resrowop->printP(), "\n";
		Carp::confess("$!") unless defined $resrowop;
		Carp::confess("$!") 
			unless $resLabel->getUnit()->call($resrowop);
		
}
</pre>

		<para>
		From the example with the manual iteration:
		</para>

<!-- t/xJoin.t, doLookupLeftManual, removed saveJoinerTo -->
<pre>
our $join = Triceps::LookupJoin->new(
	unit => $uJoin,
	name => "join",
	leftRowType => $rtInTrans,
	rightTable => $tAccounts,
	rightIdxPath => ["lookupSrcExt"],
	rightFields => [ "internal/acct" ],
	by => [ "acctSrc" => "source", "acctXtrId" => "external" ],
	automatic => 0,
); # would die by itself on an error
</pre>

		<para>
		comes this code:
		</para>

<pre>
sub  # ($self, $row)
{
	my ($self, $row) = @_;

	#print STDERR "DEBUGX LookupJoin " . $self->{name} . " in: ", $row->printP(), "\n";

	my @leftdata = $row->toArray();

	my $lookuprow = $self->{rightRowType}->makeRowHash(
		source => $leftdata[1],
		external => $leftdata[2],
		);
	
	#print STDERR "DEBUGX " . $self->{name} . " lookup: ", $lookuprow->printP(), "\n";
	my $rh = $self->{rightTable}->findIdx($self->{rightIdxType}, $lookuprow);
	Carp::confess("$!") unless defined $rh;

	my @rightdata; # fields from the right side, defaults to all-undef, if no data found
	my @result; # the result rows will be collected here

	if (!$rh->isNull()) {
		#print STDERR "DEBUGX " . $self->{name} . " found data: " . $rh->getRow()->printP() . "\n";
		@rightdata = $rh->getRow()->toArray();
	}

		my @resdata = ($leftdata[0],
		$leftdata[1],
		$leftdata[2],
		$leftdata[3],
		$rightdata[2],
		);
		push @result, $self->{resultRowType}->makeRowArray(@resdata);
		#print STDERR "DEBUGX " . $self->{name} . " +out: ", $result[$#result]->printP(), "\n";
	return @result;
}
</pre>

		<para>
		It takes different arguments because now it's not an input label handler
		but a common function that gets called from both the label handler and the
		<pre>lookup()</pre> method. And it collects the rows in an array to be returned
		instead of immediately passing them on.
		</para>

		<para>
		From the example with multiple rows matching on the right side
		</para>

<!-- t/xJoin.t, doLookupLeftMulti and the type def before it, removed saveJoinerTo -->
<pre>
our $join = Triceps::LookupJoin->new(
	unit => $uJoin,
	name => "join",
	leftRowType => $rtInTrans,
	rightTable => $tAccounts,
	rightIdxPath => [ "iterateSrc", "lookupSrcExt" ],
	rightFields => [ "internal/acct" ],
	by => [ "acctSrc" => "source", "acctXtrId" => "external" ],
); # would die by itself on an error
</pre>

		<para>
		comes this code:
		</para>

<pre>
sub # ($inLabel, $rowop, $self)
{
	my ($inLabel, $rowop, $self) = @_;
	#print STDERR "DEBUGX LookupJoin " . $self->{name} . " in: ", $rowop->printP(), "\n";

	my $opcode = $rowop->getOpcode(); # pass the opcode
	my $row = $rowop->getRow();

	my @leftdata = $row->toArray();

	my $resRowType = $self->{resultRowType};
	my $resLabel = $self->{outputLabel};

	my $lookuprow = $self->{rightRowType}->makeRowHash(
		source => $leftdata[1],
		external => $leftdata[2],
		);
	
	#print STDERR "DEBUGX " . $self->{name} . " lookup: ", $lookuprow->printP(), "\n";
	my $rh = $self->{rightTable}->findIdx($self->{rightIdxType}, $lookuprow);
	Carp::confess("$!") unless defined $rh;

	my @rightdata; # fields from the right side, defaults to all-undef, if no data found
	my @result; # the result rows will be collected here

	if ($rh->isNull()) {
		#print STDERR "DEBUGX " . $self->{name} . " found NULL\n";

		my @resdata = ($leftdata[0],
		$leftdata[1],
		$leftdata[2],
		$leftdata[3],
		$rightdata[2],
		);
		my $resrowop = $resLabel->makeRowop($opcode, $resRowType->makeRowArray(@resdata));
		#print STDERR "DEBUGX " . $self->{name} . " +out: ", $resrowop->printP(), "\n";
		Carp::confess("$!") unless defined $resrowop;
		Carp::confess("$!") 
			unless $resLabel->getUnit()->call($resrowop);
		
	} else {
		#print STDERR "DEBUGX " . $self->{name} . " found data: " . $rh->getRow()->printP() . "\n";
		my $endrh = $self->{rightTable}->nextGroupIdx($self->{iterIdxType}, $rh);
		for (; !$rh->same($endrh); $rh = $self->{rightTable}->nextIdx($self->{rightIdxType}, $rh)) {
			@rightdata = $rh->getRow()->toArray();
		my @resdata = ($leftdata[0],
		$leftdata[1],
		$leftdata[2],
		$leftdata[3],
		$rightdata[2],
		);
		my $resrowop = $resLabel->makeRowop($opcode, $resRowType->makeRowArray(@resdata));
		#print STDERR "DEBUGX " . $self->{name} . " +out: ", $resrowop->printP(), "\n";
		Carp::confess("$!") unless defined $resrowop;
		Carp::confess("$!") 
			unless $resLabel->getUnit()->call($resrowop);
		
		}
	}
}
</pre>

		<para>
		It's more complicated in two ways: If a match is found, it has to
		iterate through the whole matching group. And if the match is not
		found, it still has to produce a result row for the left join with a
		separate code fragment.
		</para>

		<para>
		</para>

		<para>
		</para>

	</sect1>

</chapter>
