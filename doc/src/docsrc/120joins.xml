<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5CR3//EN"
	"http://www.oasis-open.org/docbook/xml/4.5CR3/docbookx.dtd" [
<!ENTITY % userents SYSTEM "file:///ENTS/user.ent" >
%userents;
]>

<!--
(C) Copyright 2011-2012 Sergey A. Babkin.
This file is a part of Triceps.
See the file COPYRIGHT for the copyright notice and license information
-->

<chapter id="ch_joins" xmlns:xi="http://www.w3.org/2001/XInclude">
	<title>Joins</title>

	<sect1 id="sc_joins_variety">
		<title>Joins variety</title>

		<indexterm>
			<primary>join</primary>
		</indexterm>
		<para>
		The joins are quite important for the relational data processing, and
		come in many varieties. And the CEP systems have their own specifics.
		Basically, in CEP you want the joins to be processed fast. The CEP
		systems deal with the changing model state, and have to process these
		changes incrementally.
		</para>

		<para>
		A small change should be handled fast. It has to use the indexes to
		find and update all the related result rows. Even though you can make
		it just go sequentially through all the rows and find the relevant
		ones, like in a common database, that's not what you normally want.
		When something like this happens, the usual reaction is <quote>wtf is my
		model suddenly so slow?</quote> following by an annoyingly long investigation
		into the reasons of the slowness, and then rewriting the model to make
		it work faster. It's better to just prevent the slowness in the first
		place and make sure that the joins always use an index. And since you
		don't have to deal much with the ad-hoc queries when you write a CEP
		model, you can provide all the needed indexes in advance very easily.
		</para>

		<indexterm>
			<primary>join</primary>
			<secondary>equi-join</secondary>
		</indexterm>
		<indexterm>
			<primary>index</primary>
			<secondary>sorted</secondary>
		</indexterm>
		<indexterm>
			<primary>Aleri</primary>
		</indexterm>
		<para>
		A particularly interesting kind of joins in this regard is the
		equi-joins: ones that join the rows by the equality of the fields in
		them. They allow a very efficient index look-up. Because of this, they
		are popular in the CEP world. Some systems, like Aleri, support only
		the equi-joins to start with. The other systems are much more efficient
		on the equi-joins than on the other kinds of joins. At the moment
		Triceps follows the fashion of having the advanced support only for the
		equi-joins. Even though the Sorted/Ordered indexes in Triceps should allow the
		range-based comparisons to be efficient too, at the moment there are no
		table methods for the look-up of ranges, they are left for the future
		work. Of course, nothing stops you from copying an equi-join template
		and modifying it to work by a dumb iteration. Just it would be slow,
		and I didn't see much point in it.
		</para>

		<para>
		There also are three common patterns of the join usage.
		</para>

		<indexterm>
			<primary>Coral8</primary>
		</indexterm>
		<indexterm>
			<primary>join</primary>
			<secondary>lookup</secondary>
		</indexterm>
		<indexterm>
			<primary>join</primary>
			<secondary>stream-to-window</secondary>
		</indexterm>
		<para>
		In the first pattern the rows sort of go by and get enriched by looking
		up some information from a table and tacking it onto these rows.
		Sometimes not even tacking it on but maybe just filtering the data:
		passing through some of the rows and throwing away the rest, or
		directing the rows into the different kinds of processing, based on the
		looked-up data. For a reference, in the Coral8 CCL this situation is
		called <quote>stream-to-window joins</quote>. In Triceps there are no streams and no
		windows, so I just call them the <quote>lookup joins</quote>.
		</para>

		<indexterm>
			<primary>join</primary>
			<secondary>tables</secondary>
		</indexterm>
		<para>
		In the second pattern multiple stateful tables are joined together.
		Whenever any of the tables changes, the join result also changes, and
		the updates get propagated through. This can be done through lookups,
		but in reality it turns out that defining manually the lookups for the
		every possible table change becomes tedious pretty quickly. This has to
		be addressed by the automation.
		</para>

		<indexterm>
			<primary>join</primary>
			<secondary>self</secondary>
		</indexterm>
		<para>
		In the third pattern the same table gets joined recursively,
		essentially traversing a representation of a tree stored in that table.
		This actually doesn't work well with the classic SQL unless the
		recursion depth is strictly limited. There are SQL extensions for the
		recursive self-joins in the modern databases but I haven't seen them in the
		CEP systems yet. Anyway, the procedural approach tends to work for this
		situation much better than the SQLy one, so the templates tend to be of
		not much help. I'll show a templated and a manual example of this kind
		for comparison.
		</para>
	</sect1>

	<sect1 id="sc_joins_hello">
		<title>Hello, joins!</title>

		<para>
		As usual, let me show a couple of little teasers before starting the
		long bottom-up discussion. We'll eventually get by the long
		way to the same examples, so here I'll show only some very short
		code snippets and basic explanations.
		</para>

<!-- t/xJoin.t, doLookupFull, replaced leftFields from commented-out, removed fieldsLeftFirst, isLeft -->
<pre>
our $join = Triceps::LookupJoin->new(
	name => "join",
	leftFromLabel => $lbTrans,
	rightTable => $tAccounts,
	rightIdxPath => ["lookupSrcExt"],
	leftFields => [ "!acct.*", ".*" ],
	rightFields => [ "internal/acct" ],
	by => [ "acctSrc" => "source", "acctXtrId" => "external" ],
);
</pre>

		<indexterm>
			<primary>join</primary>
			<secondary>lookup</secondary>
		</indexterm>
		<para>
		This is a lookup join that gets the incoming rows with transactions
		data from the label <pre>$lbTrans</pre>, finds the account translation in the
		table <pre>$tAccounts</pre>, and translates the external account representation
		to internal one on its output. The join condition is an equivalent of the
		SQLy
		</para>

		<indexterm>
			<primary>SQL</primary>
		</indexterm>
<pre>
on 
	lbTrans.acctSrc = tAccounts.source
	and lbTrans.acctXtrId = tAccounts.external
</pre>

		<para>
		The condition looks up the rows in <pre>$tAccounts</pre> using the index <pre>lookupSrcExt</pre>
		that must have the key fields <pre>source</pre> and <pre>external</pre>.
		</para>

		<para>
		The result fields will contain all the fields from <pre>$lbTrans</pre> except those
		starting with <quote>acct</quote> plus the field <pre>internal</pre> from <pre>$tAccounts</pre>
		that becomes renamed to <pre>acct</pre>.
		</para>

		<para>
		Next goes a table join:
		</para>

<!-- t/xJoin.t, doJoinInner -->
<pre>
our $join = Triceps::JoinTwo->new(
	name => "join",
	leftTable => $tPosition,
	leftIdxPath => [ "currencyLookup" ],
	rightTable => $tToUsd,
	rightIdxPath => [ "primary" ],
	type => "inner",
);
</pre>

		<indexterm>
			<primary>join</primary>
			<secondary>tables</secondary>
		</indexterm>
		<para>
		It joins the tables <pre>$tPosition</pre> and <pre>$tToUsd</pre>, with the inner join logic.
		The table <pre>$tPosition</pre> uses its index <pre>currencyLookup</pre>, and <pre>$tToUsd</pre> uses
		its index <pre>primary</pre>. The join condition is determined by pairing the
		key fields of the indexes.
		</para>
	</sect1>

	<sect1 id="sc_joins_lookup_manual">
		<title>The lookup join, done manually</title>

		<para>
		First let's look at a lookup done manually. It would also establish the
		baseline for the further joins.
		</para>

		<para>
		For the background of the model, let's consider the trade information
		coming in from multiple sources. Each source system has its own
		designation of the accounts on which the trades happen but ultimately
		they are the same accounts. So there is a table that contains the
		translation from the account designations of various external systems
		to our system's own internal account identifier. This gets described
		with the row types:
		</para>

<!-- t/xJoin.t -->
<pre>
our $rtInTrans = Triceps::RowType->new( # a transaction received
	id => "int32", # the transaction id
	acctSrc => "string", # external system that sent us a transaction
	acctXtrId => "string", # its name of the account of the transaction
	amount => "int32", # the amount of transaction (int is easier to check)
) or confess "$!";

our $rtAccounts = Triceps::RowType->new( # account translation map
	source => "string", # external system that sent us a transaction
	external => "string", # its name of the account in the transaction
	internal => "int32", # our internal account id
) or confess "$!";
</pre>

		<para>
		Other than those basics, the rest of information is only minimal, to
		keep the examples smaller. Even the trade ids are expected to be global
		and not per the source systems (which is not realistic but saves
		another little bit of work).
		</para>

		<para>
		The accounts table can be indexed in multiple ways for multiple
		purposes, say:
		</para>

<!-- t/xJoin.t -->
<pre>
our $ttAccounts = Triceps::TableType->new($rtAccounts)
	->addSubIndex("lookupSrcExt", # quick look-up by source and external id
		Triceps::IndexType->newHashed(key => [ "source", "external" ])
	)
	->addSubIndex("iterateSrc", # for iteration in order grouped by source
		Triceps::IndexType->newHashed(key => [ "source" ])
		->addSubIndex("iterateSrcExt", 
			Triceps::IndexType->newHashed(key => [ "external" ])
		)
	)
	->addSubIndex("lookupIntGroup", # quick look-up by internal id (to multiple externals)
		Triceps::IndexType->newHashed(key => [ "internal" ])
		->addSubIndex("lookupInt", Triceps::IndexType->newFifo())
	)
or confess "$!";
$ttAccounts->initialize() or confess "$!";
</pre>

		<para>
		For our purpose of joining, the first, primary key is the way to go.
		Using the primary key also has the advantage of making sure that there
		is no more than one row for each key value.
		</para>

		<indexterm>
			<primary>join</primary>
			<secondary>manual lookup</secondary>
		</indexterm>
		<indexterm>
			<primary>join</primary>
			<secondary>filter</secondary>
		</indexterm>
		<indexterm>
			<primary>join</primary>
			<secondary>lookup</secondary>
		</indexterm>
		<para>
		The first manual lookup example will just do the filtering: find, whether there is a match
		in the translation table, and if so then pass the row through. The
		example goes as follows:
		</para>

<!-- t/xJoin.t, doManualLookup -->
<pre>
our $uJoin = Triceps::Unit->new("uJoin");

our $tAccounts = $uJoin->makeTable($ttAccounts, 
	"EM_CALL", "tAccounts") or confess "$!";

my $lbFilterResult = $uJoin->makeDummyLabel($rtInTrans, "lbFilterResult");
my $lbFilter = $uJoin->makeLabel($rtInTrans, "lbFilter", undef, sub {
	my ($label, $rowop) = @_;
	my $row = $rowop->getRow();
	my $rh = $tAccounts->findBy(
		source => $row->get("acctSrc"),
		external => $row->get("acctXtrId"),
	);
	if (!$rh->isNull()) {
		$uJoin->call($lbFilterResult->adopt($rowop));
	}
}) or confess "$!";

# label to print the changes to the detailed stats
makePrintLabel("lbPrint", $lbFilterResult);

while(&readLine) {
	chomp;
	my @data = split(/,/); # starts with a command, then string opcode
	my $type = shift @data;
	if ($type eq "acct") {
		$uJoin->makeArrayCall($tAccounts->getInputLabel(), @data);
	} elsif ($type eq "trans") {
		$uJoin->makeArrayCall($lbFilter, @data);
	}
	$uJoin->drainFrame(); # just in case, for completeness
}
</pre>

		<para>
		The <pre>findBy()</pre> is where the join actually happens: the lookup of the data
		in a table by values from another row. Very similar to what the
		basic window example in
		<xref linkend="sc_table_hello" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;
		was doing before. It's <pre>findBy()</pre>, without the need for <pre>findByIdx()</pre>,
		because in this case the index type used in the accounts table is its
		first leaf index, to which <pre>findBy()</pre> defaults.
		After that the fact of
		successful or unsuccessful lookup is used to pass the original row
		through or throw it away. If the found row were used to pick some
		fields from it and stick them into the result, that would be a more
		complete join, more like what you often expect to see.
		</para>

		<para>
		And here is an example of the input processing:
		</para>

<!-- t/xJoin.t, doManualLookup -->
<exdump>
> acct,OP_INSERT,source1,999,1
> acct,OP_INSERT,source1,2011,2
> acct,OP_INSERT,source2,ABCD,1
> trans,OP_INSERT,1,source1,999,100
lbFilterResult OP_INSERT id="1" acctSrc="source1" acctXtrId="999" amount="100" 
> trans,OP_INSERT,2,source2,ABCD,200
lbFilterResult OP_INSERT id="2" acctSrc="source2" acctXtrId="ABCD" amount="200" 
> trans,OP_INSERT,3,source2,QWERTY,200
> acct,OP_INSERT,source2,QWERTY,2
> trans,OP_DELETE,3,source2,QWERTY,200
lbFilterResult OP_DELETE id="3" acctSrc="source2" acctXtrId="QWERTY" amount="200" 
> acct,OP_DELETE,source1,999,1
</exdump>

		<para>
		It starts with populating the accounts table. Then the transactions that
		find the match pass, and those who don't find don't pass. If more of
		the account translations get added later, the transactions for them
		start passing but as you can see, the result might be slightly
		unexpected: you may get a DELETE that had no matching previous INSERT,
		as happened for the row with id=3.
		This happens because the lookup join keeps no history on its left side
		and can't react properly to the changes to the table on the right.
		Because of this, the lookup joins work best when the reference table
		gets pre-populated in advance and then stays stable.
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

	</sect1>

</chapter>
