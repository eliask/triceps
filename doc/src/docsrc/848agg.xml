<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5CR3//EN"
	"http://www.oasis-open.org/docbook/xml/4.5CR3/docbookx.dtd" [
<!ENTITY % userents SYSTEM "file:///ENTS/user.ent" >
%userents;
]>

<!--
(C) Copyright 2011-2013 Sergey A. Babkin.
This file is a part of Triceps.
See the file COPYRIGHT for the copyright notice and license information
-->

	<sect1 id="sc_cpp_aggregator">
		<title>Aggregator classes reference</title>

	<sect2 id="sc_cpp_aggregator_type">
		<title>AggregatorType reference</title>

		<indexterm>
			<primary>AggregatorType</primary>
		</indexterm>
		<para>
		The AggregatorType is a base class from which you derive the concrete
		aggregator types, similarly to how it's done for the index types.
		It has a chunk of functionality common for all the aggregator types and
		the virtual functions that create the aggregator objects.
		</para>

<pre>
AggregatorType(const string &name, const RowType *rt);
</pre>

		<para>
		The constructor provides a name and the result row type. Remember, that
		AggregatorType is an abstract class,  and will never be instantiated
		directly. Instead your subclass that performs a concrete aggregation
		will invoke this constructor as a part of its constructor.
		</para>

		<para>
		As has been described in the Perl part of the manual, the aggregator
		type is unique in the fact that it has a name.  And it's a bit weird
		name: each aggregator type is kind of by itself and can be reused in
		multiple table types, but all the aggregator types in a table type must
		have different names. This is the name that is used to generate the
		name of the aggregator's output label in a table:
		<quote><i>table_name.aggregator_type_name</i></quote>. Fundamentally, the aggregator
		type itself should not have a name, it should be given a name when
		connected to an index in the table type. But at the time the current
		idea looked good enough, it's easy, convenient for error messages, and
		doesn't get much in the way.
		</para>

		<para>
		The result row type might not be known at the time of the aggregator
		type creation. All the constructor does with it is place the value into
		a reference field, so if the right type is not known, just use NULL,
		then change later at the initialization time.
		If it's still NULL after initialization, this will be reported as an 
		initialization error.
		</para>

<pre>
AggregatorType(const AggregatorType &agg);
virtual AggregatorType *copy() const;
AggregatorType(const AggregatorType &agg, HoldRowTypes *holder);
virtual AggregatorType *deepCopy(HoldRowTypes *holder) const;
</pre>

		<para>
		An aggregator type must provide the copy constructors 
		and the virtual methods that invoke them. 
		Both kinds of copies are deep but <pre>deepCopy()</pre> is even deeper,
		copying even the row types.
		XXXREF HoldRowTypes
		XXXREF discussion of copy varieties
		</para>

		<para>
		The basic copy is the same as
		with the index types: when an agggregator type gets connected into a
		table type, it gets actually copied, and the copy must always be
		uninitialized.
		</para>

		<para>
		The virtual methods are typically defined in the subclasses as follows:
		</para>

<pre>
AgregatorType *MyAggregatorType::copy() const
{
	return new MyAggregatorType(*this);
}

AgregatorType *MyAggregatorType::deepCopy(HoldRowTypes *holder) const
{
	return new MyAggregatorType(*this, holder);
}
</pre>

		<para>
		Some of the fields in the AggregatorType are directly usable
		by the subclasses:
		</para>

<pre>
const_Autoref<RowType> rowType_; // row type of result
Erref errors_; // errors from initialization
string name_; // name inside the table's dotted namespace
int pos_; // a table has a flat vector of AggregatorGadgets in it, this is the index for this one (-1 if not set)
bool initialized_; // flag: already initialized, no future changes
</pre>

		<variablelist>
			<varlistentry>
				<term>rowType_</term>
				<listitem>
				<para>
				is the row type of the result. The constructor puts
				the argument value there but it can be changed at any time
				(until the initialization is completed) later.
				</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>errors_</term>
				<listitem>
				<para>
				is a place to put the errors during initialization. It
				comes set to NULL, so if you want to report any errors, you
				have to create an Errors object first, there are the
				helper functions for that.
				</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>name_</term>
				<listitem>
				<para>
				is where the aggregator name is kept. Generally, don't change it,
				treat it as read-only.
				</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>pos_</term>
				<listitem>
				<para>
				has to do with management of the aggregator types in a
				table type. Before initialization it's -1, after initialization
				each aggregator type (that becomes tied to its table type) will
				be assigned a sequential number. Again, treat it as read-only,
				and you probably would never need to even read it.
				</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>initialized_</term>
				<listitem>
				<para>
				shows that the initialization has already
				happened. Your initialization should call the initialization
				of the base class, which would set this flag. No matter if the
				initialization succeesed or failed, this flag gets set. It
				never gets reset in the original AggregatorType object, it gets
				reset only in the copies.
				</para>
				</listitem>
			</varlistentry>
		</variablelist>

<pre>
const string &getName() const;
const RowType *getRowType() const;
bool isInitialized() const;
virtual Erref getErrors() const;
</pre>

		<para>
		The convenience getter functions that return the data from the fields.
		You can override <pre>getErrors()</pre> but there probably is no point to it.
		</para>

<pre>
virtual bool equals(const Type *t) const;
virtual bool match(const Type *t) const;
</pre>

		<para>
		The equality and match comparisons are as usual. The defaults provided
		in the base AggregatorType check that the result row type is equal or
		matching (or that both result row types are NULL), and
		that the &Cpp; typeid of both are the same. So if your aggregator type has no
		parameters, this is good enough and you don't need to redefine these
		methods. If you do have parameters, you call the base class method
		first, if it returns false, you return false, otherwise you check the
		parameters. Like this:
		</para>

<pre>
bool MyAggregatorType::equals(const Type *t) const
{
     if (!AggregatorType::equals(t))
        return false;

    // the typeid matched, so safe to cast
    const MyAggregatorType *at = static_cast<const MyAggregatorType *>(t);
    // ... check the type-specific parameters ...
}
</pre>

		<para>
		The other method that you can re-define or leave alone is printTo():
		</para>

<pre>
virtual void printTo(string &res, const string &indent = "", const string &subindent = "  ") const;
</pre>

		<para>
		The default one prints <quote>aggregator (<i>result row type</i>) <i>name</i></quote>. If you
		want to print more information, such as the name of the aggregator
		class and its arguments, you can define your own.
		</para>

<pre>
virtual void initialize(TableType *tabtype, IndexType *intype);
</pre>

		<para>
		This method is called at the TableType initialization time, as it goes through
		all the components. This is the place where the aggregator type parses its
		arguments, matches them up with the information about the table type and produces
		any parsed internal representations. It may also compute the
		aggregation result type if that was not done earlier. The <pre>initialize()</pre>
		method in the subclass must always call the method in the parent class,
		to let it do its part. If any errors are found, they must be reported by
		setting an Errors object in the field <pre>errors_</pre>. If the aggregator
		type has no parameters, and its result type was set in the constructor,
		it doesn't have to define the <pre>initialize()</pre> method.
		</para>

		<para>
		Finally, there are methods that will produce objects that do the actual
		work:
		</para>

<pre>
virtual AggregatorGadget *makeGadget(Table *table, IndexType *intype) const;
virtual Aggregator *makeAggregator(Table *table, AggregatorGadget *gadget);
</pre>

		<indexterm>
			<primary>BasicAggregatorType</primary>
		</indexterm>
		<indexterm>
			<primary>IndexType</primary>
		</indexterm>
		<indexterm>
			<primary>SortedIndexType</primary>
		</indexterm>
		<para>
		This exposes quite a bit of the inherent complexity of the aggregators.
		For the simpler cases you can use the subclass BasicAggregatorType that
		handles most of this complexity for you and just skip these <quote>make</quote>
		methods. By the way, the IndexType has a <quote>make</quote> method of this kind too
		but it was not discussed because unless you define a completely new
		IndexType, you don't need to worry about it: it just happens under the
		hood. The SortedIndexType just asks you to define a condition and takes
		care of the rest, like the BasicAggregatorType for aggregators.
		</para>
	</sect2>

	<sect2 id="sc_cpp_aggregator_gadget">
		<title>AggregatorGadget reference</title>

		<para>
		The Gadget concept is discussed in
		<xref linkend="sc_cpp_gadget" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;.
		Each aggregator in a table is a gadget. So whenever a table is
		created from a table type, each aggregator type in that table type is
		called to produce its gadget, and these gadgets are collected in the
		table. When you call <pre>table->getAggregatorLabel("name")</pre>, you get the
		output label from the appropriate gadget.
		</para>

		<para>
		The short summary: one AggregatorGadget per table per aggregator type.
		</para>

		<indexterm>
			<primary>AggregatorGadget</primary>
		</indexterm>
		<indexterm>
			<primary>Gadget</primary>
		</indexterm>
		<para>
		The AggregatorGadget is a subclass of Gadget that keeps the extra
		information typically needed by all the aggregator types. It's defined in
		<pre>sched/AggregatorGadget.h</pre>. 
		The original grand plan was that the different aggregator types may
		define their own subclasses of AggregatorGadget but in reality there
		appears no need to. So far all the aggregators happily live with the
		base AggregatorGadget.  It's constructed as:
		</para>

<pre>
AggregatorGadget(const AggregatorType *type, Table *table, IndexType *intype);
</pre>

		<para>
		The arguments are pretty much a pass-through from the <pre>makeGadget()</pre>.
		The AggregatorGadget will keep references to the AggregatorType and
		to the IndexType, and a pointer to the Table, for the future use.
		The reason why the Table is not referenced is that it would create
		cyclic references, because the table already references
		all its aggregator gadgets. There is normally no need to worry that the
		table will disappear: when the table is destroyed, it will never call
		the aggregator gadget again. And that would remove the references
		to the Aggregator and AggregatorGadget, thus likely causing them
		to be destroyed too (unless you hold another reference to
		AggregatorGadget from outside Aggregator, which you normally should
		not).
		</para>

		<para>
		This information can be obtained back from the AggregatorGadget with:
		</para>

<pre>
Table *getTable() const;
const AggregatorType *getType() const;
template<class C> const C *typeAs() const;
const IndexType *getIndexType() const;
</pre>

		<para>
		The AggregatorType can be extracted in two ways, as a plain base
		class pointer with <pre>getType()</pre> and with the template <pre>typeAs()</pre> that
		casts it to the appropriate subclass. For example:
		</para>

<pre>
MyAggregatorType *agt = gadget->typeAs<MyAggregatorType>();
</pre>

		<para>
		Of course, the subclasses can also read the fields directly.
		</para>

		<para>
		The AggregatorGadget also publicly exports the method <pre>sendDelayed()</pre>
		of the Gadget (which is normally protected) and provides
		a convenience wrapper that constructs a row from fields data
		and sends it:
		</para>

<pre>
void sendDelayed(Tray *dest, const Row *row, Rowop::Opcode opcode) const
void sendDelayed(Tray *dest, FdataVec &data, Rowop::Opcode opcode) const;
</pre>

		<para>
		The Gadget method <pre>send()</pre> is not exported, and is even marked as
		private. The rows are always sent from the aggregators in the delayed
		fashion. The reasons for that are partially historic, having to do with
		the per-Gadget enqueueing modes, but the bigger reason is that it also helps with the error
		handling inside the Table and Aggregator code, separating the errors in
		the Aggregators themselves from the errors in the labels called by
		them.
		</para>
	</sect2>

	<sect2 id="sc_cpp_aggregator_obj">
		<title>Aggregator reference</title>

		<para>
		Unlike AggregatorGadget, an Aggergator represents a concrete aggregation 
		group, on a concrete index (not on an index type, on an index!). Whenever an index
		of some type is created, an aggregator of its connected type is created
		with it. Remember, an index contains a single aggregation group. A table with nested indexes can have
		lots of aggregators of a single type. The difference between an index
		type and an index is explained in detail in
		<xref linkend="sc_table_indextree" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;,
		and the available Index methods are enumerated in
		<xref linkend="sc_cpp_idx" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;.
		</para>

		<para>
		The way it works, whenever some row in the table gets deleted or
		inserted, the table determines for each index type, which actual index
		in the tree (i.e. which group) got changed. Then for aggregation
		purposes, if that index has an aggegator on it, that aggregator is
		called to do its work on the group. It produces an output row or two
		(or maybe none, or it can get creative and produce many rows) 
		for that group and sends it to the aggregator gadget of
		the same type.
		</para>

		<para>
		The short summary: one Aggregator object per group, produces
		the updates when asked, sends them to the single common gadget.
		</para>

		<para>
		The pointers to the Table and Gadget are passed to the <pre>makeAggregator()</pre>  method
		for convenience, the Aggergator object doesn't need to remember them. Whenever
		it will be called, it will also be given these pointers as arguments.
		This is done in an attempt to reduce the amount of data stored per
		aggregator. 
		</para>

		<indexterm>
			<primary>Aggregator</primary>
		</indexterm>
		<para>
		The Aggregator class (defined in <pre>table/Aggregator.h</pre>) is the
		base class for the per-aggregation-group objects. Its main purpose
		is in the handler method:
		</para>

		<indexterm>
			<primary>Aggregator</primary>
			<secondary>handler</secondary>
		</indexterm>
		<indexterm>
			<primary>AggOp</primary>
		</indexterm>
<pre>
virtual void handle(Table *table, AggregatorGadget *gadget, Index *index,
	const IndexType *parentIndexType, GroupHandle *gh, Tray *dest,
	AggOp aggop, Rowop::Opcode opcode, RowHandle *rh);
</pre>

		<para>
		In retrospect, this method might be better off belonging to the
		AggregatorType class, but for now it is what it is.
		</para>

		<para>
		You would create a subclass that would get instantiated for every
		aggregation group. Then the handler would be called every time
		this group gets modified, exactly as it was described for the
		Perl API. The arguments are fundamentally the same as in Perl,
		just structured differently: they're passed directly instead of
		being hidden in an aggregation context. The &Cpp;  programmers are
		expected to behave responsibly and not try to mess with these
		parameters outside of the call scope, or prepare to meet the dire
		consequences.
		</para>

		<para>
		Before digging more into the arguments, a few more words about the
		subclass structure.  The subclass may define any additional fields to
		keep its aggregation state.  If you're doing an additive aggregation,
		it allows you to keep the previous results. If you're doing the
		optimization of the deletes, it allows you to keep the previous sent
		row.
		</para>

		<para>
		What if your aggregator keeps no state? You still have to make a
		separate Aggregator object for every group, and no, you can't just
		return NULL from <pre>makeAggregator()</pre>, and no, the Aggregators
		are not reference-countable, so you have to make a new copy of it for
		every group. This looks decidedly sub-optimal, and eventually I'll get
		around to straighten it out. The good news though is that most of the
		real aggerators keep the state anyway, so it doesn't matter much.  
		</para>

		<para>
		Now getting back to the arguments. Probably the easiest way is to
		start with showing how the Perl AggregatorContext calls translate
		to the &Cpp; API.
		</para>

		<indexterm>
			<primary>AggregatorContext</primary>
		</indexterm>
		<indexterm>
			<primary>Index</primary>
		</indexterm>
		<indexterm>
			<primary>GroupHandle</primary>
		</indexterm>
		<variablelist>
			<varlistentry>
				<term><pre>$result = $ctx->groupSize();</pre></term>
				<listitem>
<pre>
size_t sz = parentIndexType->groupSize(gh);
</pre>
				<para>
				Get the size of the group. The result is of the type size_t.
				This is pretty much the only method of the IndexType base class that should be
				called directly, and only in the aggregation; and also pretty much the
				only use of the arguments <pre>parentIndexType</pre> and <pre>gh</pre>. 
				The rest of the IndexType methods should be accessed through the similar
				methods in the Table, and I won't even document them. However
				if you really, really want to, you can find the description of
				the other methods in <pre>type/IndexType.h</pre> and call them in the
				aggregation as well.
				</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>$rowType = $ctx->resultType();</pre></term>
				<listitem>
<pre>
const RowType *rt = gadget->getLabel()->getType();
</pre>
				<para>
				</para>
				Get the result row type.
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>$rh = $ctx->begin();</pre></term>
				<listitem>
<pre>
RowHandle *rhi = index->begin();
</pre>
				<para>
				Get the first row handle of the group, in the order of the index
				(or technically, if it's not a leaf index, of its first leaf sub-index).
				As usual, it would return NULL if the group is empty.
				The aggregators are a weird place where the Index methods are
				called directly and not through the Table API. You <i>could</i>
				use the Table API as well, by getting the index type with
				<pre>index->getType()</pre>, and then using it in the table API,
				but then you would also need to supply a sample row from the group
				to the Table API, and getting that sample is also done through
				<pre>index->begin()</pre>, so there is no way around it. Note that
				you can't just use the <pre>rh</pre> argument, since it might be
				the handle that had already been deleted from the table.
				Besides, going directly to the index is slightly more efficient,
				since it skips the step of finding the index by its type and
				a sample row.
				</para>
				<para>
				It's fine to use a pointer to RowHandle instead of a reference here,
				since the handles are already held in the table which is guaranteed not
				to change while the iterators run.
				</para>
				<para>
				Just as in Perl's AggregatorContext, there is no <pre>index->end()</pre>.
				When the end of the group is reached, the iteration will return a NULL
				handle.
				</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>$rh = $ctx->next($rh);</pre></term>
				<listitem>
<pre>
rhi = index->next(rhi);
</pre>
				<para>
				Get the handle of the next row (or NULL if that was the last
				one) in the order of the index. The NULL argument produces the NULL
				result.
				</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>$rh = $ctx->last();</pre></term>
				<listitem>
<pre>
RowHandle *rhi = index->last();
</pre>
				<para>
				Get the handle of the last row in the group in the default order.
				Returns NULL if the group is empty.
				</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<!-- 
				 # the automatic expansion leaves line breaks between <term> and <programlisting>
				 # that mess up the formatting, so the expanded version is inserted here manually
				<term>
<pre>
$rh = $ctx->beginIdx($idxType);
$rh = $ctx->endIdx($idxType);
$rh = $ctx->lastIdx($idxType);
</pre>
				</term>
				-->
				<term><programlisting>$rh = $ctx-&gt;beginIdx($idxType);
$rh = $ctx-&gt;endIdx($idxType);
$rh = $ctx-&gt;lastIdx($idxType);</programlisting></term>
				<listitem>
<pre>
RowHandle *sample = index->begin();
RowHandle *rhend =  table->nextGroupIdx(otherIndexType, sample);
for (RowHandle *rhit = table->firstOfGroupIdx(otherIndexType, sample); rhit != rhend; rhit = table->nextIdx(otherIndexType, rhit)) {
  ...
}
</pre>
				<para>
				Unlike the Perl API of AggregatorContext, there are no direct
				analogs of beginIdx() and such in the &Cpp; API. To get them in
				&Cpp;, you need to translate the iteration to another index type
				through the Table (and of course, just like in Perl, you would
				need somehow to get the reference or pointer to another index type into
				your aggregator, and that index type better be in the subtree
				of the <pre>parentIndexType</pre>). To translate through the Table, you
				take any row from the group, usually the first one, and use it
				with the table methods that accept a sample row.
				</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>$ctx->send($opcode, $row);</pre></term>
				<listitem>
<pre>
gadget->sendDelayed(dest, row, opcode);
</pre>
				<para>
				In Perl I've named this method just <pre>send()</pre> but in &Cpp;
				it comes with its proper name of <pre>sendDelayed()</pre>.
				</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>$ctx->makeHashSend($opcode, $fieldName => $fieldValue, ...);</pre></term>
				<listitem>
<pre>
gadget->sendDelayed(dest, fields, opcode);
</pre>
				<para>
				This is a convenience wrapper that builds the row from the fields
				and sends it on.
				</para>
				</listitem>
			</varlistentry>
		</variablelist>

		<para>
		And here goes the honest description of the handler arguments:
		</para>

		<indexterm>
			<primary>Aggregator</primary>
			<secondary>handler</secondary>
		</indexterm>
		<variablelist>
			<varlistentry>
				<term><pre>Table *table</pre></term>
				<listitem>
				<para>
				Table where this Aggregator belongs.
				</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>AggregatorGadget *gadget</pre></term>
				<listitem>
				<para>
				The Gadget where this Aggregator sends its results.
				</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>Index *index</pre></term>
				<listitem>
				<para>
				Index that defines the group on which this Aggregator runs.
				</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>const IndexType *parentIndexType</pre></term>
				<listitem>
				<para>
				The IndexType of the parent Index, one level above the <pre>index</pre>
				argument. It's needed mostly because the group size is kept at that
				level.
				</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>GroupHandle *gh</pre></term>
				<listitem>
				<para>
				This is an opaque object that can be used as an argument to the
				<pre>parentIndexType</pre> methods. It's an internal object that
				ties together all the indexes in the group under the parent index.
				</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>Tray *dest</pre></term>
				<listitem>
				<para>
				The tray where the results will be collected. This tray is created and
				then processed by the Table logic.
				</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>AggOp aggop</pre></term>
				<listitem>
				<para>
				The aggregation operation, with the same meaning as described for Perl in 
				<xref linkend="sc_aggregation_manual" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;.
				The <pre>enum AggOp</pre> is defined in the Aggregator class
				and contains the elemends AO_BEFORE_MOD, AO_AFTER_DELETE,
				AO_AFTER_INSERT, AO_COLLAPSE.
				</para>
		<indexterm>
			<primary>AggOp</primary>
		</indexterm>
		<indexterm>
			<primary>aggregation</primary>
			<secondary>operation</secondary>
		</indexterm>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>Rowop::Opcode opcode</pre></term>
				<listitem>
				<para>
				The suggested opcode for the result rowops. The meaning is also as in Perl.
				</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><pre>RowHandle *rh</pre></term>
				<listitem>
				<para>
				The handle that is about to or had just been inserted or removed, depending
				on the <pre>aggop</pre>. It may be NULL for the operation AO_COLLAPSE.
				</para>
				</listitem>
			</varlistentry>
		</variablelist>
		XXXXXXXXXXXXX AO_ to string conversions
	</sect2>
		XXXXXXXXXXXXXXXXXXXXXXX See 193-195

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

	</sect1>
