<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5CR3//EN"
	"http://www.oasis-open.org/docbook/xml/4.5CR3/docbookx.dtd" [
<!ENTITY % userents SYSTEM "file:///ENTS/user.ent" >
%userents;
]>

<!--
(C) Copyright 2011-2013 Sergey A. Babkin.
This file is a part of Triceps.
See the file COPYRIGHT for the copyright notice and license information
-->

<chapter id="ch_cpp_ref" xmlns:xi="http://www.w3.org/2001/XInclude">
	<title>Triceps &Cpp; API Reference</title>

	<sect1 id="sc_cpp_intro">
		<title>&Cpp; API Introduction</title>

		<indexterm>
			<primary>C++</primary>
		</indexterm>
		<para>
		Fundamentally, the &Cpp; and Perl APIs are shaped similarly. So I won't
		be making a version of all the examples in &Cpp;. Please read the
		Perl-based documentation first to understand the spirit and usage of
		Triceps. The &Cpp;-based documentation is more of the reference type and
		concentrates on the low-level specifics and differences from Perl
		necessitated by this specifics.
		</para>

		<para>
		In many cases just reading the descriptions of the methods in the <pre>.h</pre>
		files should be enough to understand the details and be able to use the
		API. However in some cases the class hierarchies differ, with the Perl
		API covering the complexities exposed in the &Cpp; API.
		</para>

		<para>
		Writing directly in &Cpp; is significantly harder than in Perl, so I
		highly recommend sticking with the Perl API unless you have a good
		reason to do otherwise. Even when the performance is important, it's
		usually enough to write a few critical elements in &Cpp; and then bind
		them together in Perl. (If you wonder about Java, and why I didn't use
		it instead, the answer is that Java successfully combines the drawbacks
		of both and adds some of its own).
		</para>

		<para>
		The &Cpp; Triceps API is much more sensitive to the errors. The Perl API
		checks all the arguments for consistency, it's principle is that the
		interpreter must never crash. The &Cpp; API is geared towards the
		efficiency of execution. It checks for errors when constructing the
		major elements but then does almost no checks at run time. The
		expectation is that the caller knows what he is doing. If the caller
		sends bad data, mislays the pointers etc., the program will crash. The
		idea here is that most likely the &Cpp; API will be used from another
		layer: either an interpreted one (like Perl) or a compiled one (like a
		possible future custom language). Either way that layer is responsible
		for detecting the user errors at either interpretation or compile time.
		By the time the data gets to the &Cpp; code, it's already checked and
		there is no need to check it again. Of course, if you write the
		programs manually in &Cpp;, that checking is upon you.
		</para>

		<para>
		The more high-level features are currently available only in Perl. For
		example, there are no joins in the &Cpp; API. If you want to do the joins
		in &Cpp;, you have to code your own. This will change over time, as these
		features will solidify and move to a &Cpp; implementation to become more
		efficient and available through all the APIs. But it's much easier to
		experiment with the initial implementations in Perl.
		</para>

		<para>
		The &Cpp; code is located in the <pre>cpp/</pre> subdirectory, and all
		the further descriptions refer to the subdirectories under it.
		</para>
	</sect1>

	<sect1 id="sc_cpp_const">
		<title>The const-ness in &Cpp;</title>

		<indexterm>
			<primary>const</primary>
		</indexterm>

		<para>
		I've been using the <pre>const</pre> keyword for two purposes:
		</para>

		<itemizedlist>
			<listitem>
			To let the compiler optimize a little better the methods that do not
			change the state of the objects.
			</listitem>

			<listitem>
			To mark the fragments of the read-only object internal state returned
			by the methods. This is much more efficient than making copies of them.
			</listitem>
		</itemizedlist>

		<para>
		So if you get a <pre>const vector<> &</pre> returned from a method, this is a
		gentle reminder that you should not be modifying this vector. Of
		course, nothing can stop a determined programmer from doing a type cast
		and modifying it anyway, but be aware that such inconsistent
		modifications will likely cause the program to crash in the future. And
		if the vector contains references to other objects, these objects
		usually should not be modified either, even they might not be marked
		with const.
		</para>

		<indexterm>
			<primary>const_iterator</primary>
		</indexterm>
		<para>
		However all this <pre>const</pre> stuff is not all rainbows and unicorns but also
		produces a sizable amount of suffering. One consequence is that you can
		not use the normal iterators on the <pre>const</pre> vectors, you have to use the
		const_iterators. Another is that once in a while you get something like
		a <pre>(const RowType *)</pre> from one method and need to pass it as an argument
		to another method that takes a <pre>(RowType *)</pre>. In this case make sure that
		you know what you are doing and then proceed boldly with using a
		<pre>const_cast</pre>. There is just no way to get all the const-ness
		self-consistent without ripping it out altogether. 
		</para>
	</sect1>

	<sect1 id="sc_cpp_mem">
		<title>Memory management in the &Cpp; API</title>

		<indexterm>
			<primary>memory management</primary>
		</indexterm>
		<para>
		The memory management fundamentals have been described in
		<xref linkend="sc_memory_fund" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;,
		and the application-level considerations have been descibed in
		<xref linkend="ch_memory" xrefstyle="select: label quotedtitle pageabbrev"/>&xrsp;.
		This section goes deeper into the issues specific to the &Cpp; API.
		</para>

		<para>
		The code related to the memory management is generally collected under <pre>mem/</pre>. 
		The memory management is done through the reference counting, which has two parts to it:
		</para>

		<itemizedlist>
			<listitem>
			The objects that can be managed by reference counting.
			</listitem>

			<listitem>
			The references that do the counting.
			</listitem>
		</itemizedlist>

		<indexterm>
			<primary>AtomicInt</primary>
		</indexterm>
		<indexterm>
			<primary>NSPR</primary>
		</indexterm>
		<para>
		The managed objects come in two varieties: single-threaded and
		multi-threaded. The single-threaded objects lead their whole life in a
		single thread, so their reference counts don't need locking. The
		multi-threaded objects can be shared by multiple threads, so their
		reference counts are kept thread-safe by using the atomic integers (if
		the NSPR library is available) or by using a lock (if NSPR is not
		used). That whole implementation of atomic data with or without NSPR is
		encapsulated in the class AtomicInt in <pre>mem/Atomic.h</pre>.
		</para>

		<para>
		The way a class selects whether it will be single-threaded or
		multi-threaded is by inheriting from the appropriate class:
		</para>

		<variablelist>
			<varlistentry>
				<term>Starget</term>
				<listitem>
		<indexterm>
			<primary>Starget</primary>
		</indexterm>
				<para>
				for single-threaded (defined in <pre>mem/Starget.h</pre>).
				</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>Mtarget</term>
				<listitem>
		<indexterm>
			<primary>Mtarget</primary>
		</indexterm>
				<para>
				for multi-threaded (defined in <pre>mem/Mtarget.h</pre>).
				</para>
				</listitem>
			</varlistentry>
		</variablelist>

		<para>
		If you do the multiple inheritance, the [SM]target has to be inherited
		only once. Also, you can't change the choice along the inheritance
		chain. Once chosen, you're stuck with it. The only way around it is by
		encapsulating that inner class's object instead of inheriting from it.
		</para>

		<indexterm>
			<primary>Autoref</primary>
		</indexterm>
		<para>
		The references are created with the template <pre>Autoref<></pre>, defined in
		<pre>mem/Autoref.h</pre>. For example, if you have an object of class RowType, the
		reference to it will be <pre>Autoref<RowType></pre>. There are are some similar
		references in the Boost library, but I prefer to avoid the avoidable
		dependencies (and anyway, I've never used Boost much).
		</para>

		<para>
		The target objects are created in the constructors with the reference
		count of 0. The first time the object pointer is assigned to an
		Autoref, the count goes up to 1. After that it stays above 0 for the
		whole life of the object. As soon as it goes back to 0 (meaning that
		the last reference to it has disappeared), the object gets destroyed. No
		locks are held during the destruction itself. After all the references
		are gone, nobody should be using it, and destroying it is safe without
		any extra locks.
		</para>

		<para>
		An important point is that to do all this, the Autoref must be able to
		execute the correct destructor when it destroys the object that ran out
		of references. Starget and Mtarget do not provide the virtual
		destructors. If you don't use the polymorphism for some class, you
		don't have to use the virtual destructors. But if you do use it, i.e.
		create a class B inheriting from A, inheriting from [SM]target, and
		then assign something like
		</para>

<pre>
Autoref<A> ref = new B;
</pre>

		<para>
		then the class A (and by extension all the classes inheriting from it)
		must have a virtual destructor to get everything working right.
		</para>

		<para>
		It's also possible to mess up the destruction with the use of pointers.
		For example, look at this sequence:
		</para>

<pre>
Autoref<RowType> rt = new RowType(...);
RowType *rtp = rt; // copies a reference to a pointer
rt = NULL; // reference cleared, count down to 0, object destroyed
Autoref <RowType> rt2 = rtp; // resurrects the dead pointer, corrupts memory
</pre>

		<para>
		The lesson here is that even though you can mix the references with
		pointers to reduce the overhead (the reference assignments change the
		reference counters, the pointer assignments don't), and I do it in my
		code, you need to be careful. A pointer may be used only when you know
		that there is a reference that holds the object in place. Once that
		reference is gone, the pointer can't be used any more, and especially
		can't be assigned to another reference. Be careful.
		</para>

		<para>
		There are more varieties of the Autoref template:
		</para>

		<itemizedlist>
			<listitem>
			Onceref
			</listitem>

			<listitem>
			const_Autoref
			</listitem>

			<listitem>
			const_Onceref
			</listitem>
		</itemizedlist>

		<indexterm>
			<primary>Onceref</primary>
		</indexterm>
		<para>
		The Onceref is an attempt at optimization when passing the function
		arguments and results. It's supposed to work like the standard
		auto_ptr: you assign a value there once, and then when that value gets
		assigned to an Autoref or another Onceref, it moves to the new
		location, leaving the reference count unchanged and the original
		Onceref as NULL. This way you avoid a spurious extra increase-decrease.
		However in practice I haven't got around to implementing it yet, so for
		now it's a placeholder that is defined to be an alias of Autoref.
		</para>

		<indexterm>
			<primary>const_Autoref</primary>
		</indexterm>
		<indexterm>
			<primary>const_iterator</primary>
		</indexterm>
		<para>
		The const_Autoref is a reference to a constant object. Essentially,
		<pre>const_Autoref<T></pre> is equivalent to <pre>Autoref<const T></pre>, only it handles the
		automatic type casts much better. The approach is patterned after the
		const_iterator. The only problem with const_Autoref is that when you
		try to assign a NULL to it, that blows the compiler's mind. So you have
		to write an explicit cast of <pre>(T*)NULL</pre> of <pre>(const T*)NULL</pre> to help it out.
		</para>

		<indexterm>
			<primary>const_Onceref</primary>
		</indexterm>
		<para>
		Finally, const_Onceref is the const version of Onceref. 
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>

		<para>
		</para>
	</sect1>

	<xi:include href="file:///DOCS/810autoref.xml"/>

</chapter>
